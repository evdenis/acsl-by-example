(* Generated by Frama-C WP *)

Goal typed_external_accumulate_loop_invariant_index_preserved.
Hint accumulate,index,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_adjacent_find_loop_invariant_bound_established.
Hint adjacent_find,bound,established.
Proof.
  auto with zarith.
Qed.

Goal typed_external_adjacent_find_loop_invariant_bound_preserved.
Hint adjacent_find,bound,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_axiom_size_of_init_ensures_size.
Hint axiom_size_of_init,default,property,size.
Proof.
  auto with zarith.
Qed.

Goal typed_external_bubble_sort_assert_reorder.
Hint bubble_sort,property,reorder.
Proof.
  auto with zarith.
Qed.

Goal typed_external_bubble_sort_assert_reorder_3.
Hint bubble_sort,property,reorder.
Proof.
  auto with zarith.
Qed.

Goal typed_external_bubble_sort_assert_reorder_4.
Hint bubble_sort,property,reorder.
Proof.
  auto with zarith.
Qed.

Goal typed_external_bubble_sort_assert_rte_unsigned_overflow_3.
Hint bubble_sort,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_bubble_sort_loop_invariant_bound_2_preserved.
Hint bound,bubble_sort,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_bubble_sort_loop_variant_2_positive.
Hint bubble_sort,positive.
Proof.
  auto with zarith.
Qed.

Goal typed_external_clamp_upper_bound_ensures_result.
Hint clamp,property,result,upper_bound.
Proof.
  auto with zarith.
Qed.

Goal typed_external_copy_backward_loop_invariant_bound_preserved.
Hint bound,copy_backward,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_copy_loop_invariant_bound_preserved.
Hint bound,copy,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_count2_loop_invariant_bound_preserved.
Hint bound,count2,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_count_loop_invariant_bound_preserved.
Hint bound,count,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_equal_range2_assert_rte_unsigned_overflow_12.
Hint equal_range2,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_equal_range2_assert_rte_unsigned_overflow_13.
Hint equal_range2,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_equal_range2_assert_rte_unsigned_overflow_6.
Hint equal_range2,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_equal_range2_assert_rte_unsigned_overflow_7.
Hint equal_range2,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_equal_range2_assert_rte_unsigned_overflow_8.
Hint equal_range2,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_fill_loop_invariant_bound_preserved.
Hint bound,fill,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_find2_loop_invariant_bound_preserved.
Hint bound,find2,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_find3_loop_invariant_bound_preserved.
Hint bound,find3,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_find_end_loop_variant_positive.
Hint find_end,positive.
Proof.
  auto with zarith.
Qed.

Goal typed_external_find_first_of_loop_invariant_bound_preserved.
Hint bound,find_first_of,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_find_if_not_loop_invariant_bound_preserved.
Hint bound,find_if_not,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_find_loop_invariant_preserved.
Hint find,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_inner_product_loop_invariant_index_preserved.
Hint index,inner_product,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_insertion_sort_loop_invariant_bound_preserved.
Hint bound,insertion_sort,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_insertion_sort_loop_invariant_reorder_preserved.
Hint insertion_sort,preserved,reorder.
Proof.
  auto with zarith.
Qed.

Goal typed_external_insertion_sort_requires_increasing.
Hint default,increasing,insertion_sort,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_iota_loop_invariant_bound_preserved.
Hint bound,iota,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_is_heap_until_ensures_last.
Hint default,is_heap_until,last,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_is_heap_until_loop_invariant_bound_preserved.
Hint bound,is_heap_until,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_is_heap_until_loop_invariant_parent_established.
Hint established,is_heap_until,parent.
Proof.
  auto with zarith.
Qed.

Goal typed_external_is_sorted_loop_variant_positive.
Hint is_sorted,positive.
Proof.
  auto with zarith.
Qed.

Goal typed_external_lemma_AccumulateBounds_Unchanged.
Hint AccumulateBounds_Unchanged,property.
Proof.
  Require Import Psatz.
  intros v n L K a.
  intros L32 K32 v32.
  assert(neg_nonneg: (n < 0 \/ 0 <= n)%Z) by lia.
  destruct neg_nonneg as [neg|nonneg].
  {
    intros Unchanged Bounds.
    unfold P_AccumulateBounds in *.
    intros; auto with zarith.
  }
  {
    apply natlike_rec3 with (z := n); auto with zarith.
    {
      intros Unchanged Bounds.
      unfold P_AccumulateBounds in *.
      intros; auto with zarith.
      assert (AccL: L_Accumulate L a 0 v = v) by (apply FixL_Accumulate; lia).
      replace i%Z with 0%Z by lia.
      rewrite AccL.
      unfold is_sint32 in *; lia.
    }
    {
      intros z zNN IHz Unchanged Bounds.
      replace (Z.pred z) with (z-1)%Z in * by lia.
      unfold P_AccumulateBounds in *.
      intros.
      assert(less_equal: (i < z \/ i = z)%Z) by lia.
      destruct less_equal as [less|equal].
      - apply IHz; auto with zarith.
        apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=0%Z) (i_2:=z); auto with zarith.
      - rewrite equal.
        rewrite Q_Accumulate_Unchanged with (t:=K); auto with zarith.
    }
  }
Qed.

Goal typed_external_lemma_AccumulateDefault_Unchanged.
Hint AccumulateDefault_Unchanged,property.
Proof.
  Require Import Psatz.
  intros n.
  intros K L a H KChunk LChunk U.
  unfold L_AccumulateDefault.
  replace (K .[ shift_sint32 a 0]) with (L .[ shift_sint32 a 0]) by auto with zarith.
  rewrite A_Accumulate.Q_Accumulate_Unchanged with (t:=L); auto.
  unfold P_Unchanged_2_.
  unfold P_Unchanged_1_.
  intros.
  rewrite shift_associative.
  apply U; lia.
Qed.

Goal typed_external_lemma_Accumulate_Unchanged.
Hint Accumulate_Unchanged,property.
Proof.
  Require Import Psatz.
  intros init n.
  intros K L a K32 L32 v32.
  (* keep Unchanged in goal for later induction *)

  assert (nonpos_pos: (n <= 0 \/ n > 0)%Z) by lia.
  destruct nonpos_pos as [nonpos|pos].
  {
    intros Unchanged.
    rewrite Q_Accumulate_Init; auto with zarith.
    rewrite Q_Accumulate_Init; auto with zarith.
  }
  {
    (* now induction *)
    apply natlike_rec3 with (z := n); auto with zarith.
    {
      (* n = 0 *)
      intros Unchanged.
      rewrite Q_Accumulate_Init; auto with zarith.
      rewrite Q_Accumulate_Init; auto with zarith.
    }
    {
      (* n > 0 *)
      intros z H IHz.
      replace (Z.pred z) with (z - 1)%Z in * by lia.
      assert (HK: (K.[shift_sint32 a (z - 1)] + L_Accumulate K a (z - 1) init = L_Accumulate K a z init)%Z).
      {
        apply (@FixL_Accumulate z init K a); lia.
      }
      assert (HL: (L.[shift_sint32 a (z - 1)] + L_Accumulate L a (z - 1) init = L_Accumulate L a z init)%Z).
      {
        apply (@FixL_Accumulate z init L a); lia.
      }
      intros U.
      rewrite <- HK.
      rewrite <- HL.
      rewrite IHz.
      - enough(K .[ shift_sint32 a (z - 1)] = L .[ shift_sint32 a (z - 1)]) by lia.
        rewrite U; lia.
      - apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=0%Z) (i_2:=z); auto with zarith.
    }
  }
Qed.

Goal typed_external_lemma_AdjacentDifferenceThenPartialSum.
Hint AdjacentDifferenceThenPartialSum,property.
Proof.
  Require Import Psatz.
  intros n L a b Nat_n.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros.
    unfold P_PartialSum.
    auto with zarith.
  }
  {
    (* induction step *)
    intros z Nat_z IHz Diff.
    unfold P_PartialSum.
    intros i. intros.
    replace (Z.succ z) with (1 + z) in * by lia.
    assert(less_equal: i < z \/ i = z) by lia.
    destruct less_equal as [less|equal].
    - apply IHz; auto with zarith.
    apply Q_AdjacentDifferenceSection with (i:=1+z); auto with zarith.
    - rewrite equal.
      (* unfold P_AdjacentDifference in Diff. *)
      assert(zero_pos: z = 0 \/ z > 0) by lia.
      destruct zero_pos as [zero|pos].
      + rewrite zero.
        rewrite <- Axiomatic4.Q_AccumulateDefault_Zero.
        rewrite Diff; auto with zarith.
      + replace z with (1 + (z-1)) by lia.
        rewrite <- Axiomatic4.Q_AccumulateDefault_Next; auto with zarith.
        rewrite <- IHz; auto with zarith.
        * replace (1 + (z-1)) with z by lia.
          rewrite Diff; auto with zarith.
          rewrite A_Difference.Q_Difference_Next; lia.
        * apply Q_AdjacentDifferenceSection with (i:=1+z); auto with zarith.
  }
Qed.

Goal typed_external_lemma_AdjacentDifference_Inverse.
Hint AdjacentDifference_Inverse,property.
Proof.
  Require Import Psatz.
  intros n L a b nNN LChunk.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros.
    unfold P_PartialSum.
    auto with zarith.
  }
  {
    (* induction step *)
    intros z Nat_z IHz Diff.
    unfold P_PartialSum.
    intros.
    replace (Z.succ z) with (1 + z) in * by lia.
    assert(less_equal: i < z \/ i = z) by lia.
    destruct less_equal as [less|equal].
    - apply IHz; auto with zarith.
      apply A_AdjacentDifference.Q_AdjacentDifference_Section with (i:=1+z); auto with zarith.
    - rewrite equal.
      (* unfold P_AdjacentDifference in Diff. *)
      assert(zero_pos: z = 0 \/ z > 0) by lia.
      destruct zero_pos as [zero|pos].
      + rewrite zero.
        rewrite <- A_AccumulateDefault.Q_AccumulateDefault_One; auto with zarith.
        rewrite Diff; auto with zarith.
      + replace z with (1 + (z-1)) by lia.
        rewrite <- A_AccumulateDefault.Q_AccumulateDefault_Next; auto with zarith.
        rewrite <- IHz; auto with zarith.
        * replace (1 + (z-1)) with z by lia.
          rewrite Diff; auto with zarith.
          rewrite A_Difference.Q_Difference_Next; auto with zarith.
        * apply A_AdjacentDifference.Q_AdjacentDifference_Section with (i:=1+z); auto with zarith.
  }
Qed.

Goal typed_external_lemma_CircularShift_MultisetReorder.
Hint CircularShift_MultisetReorder,property.
Proof.
  Require Import Psatz.
  intros m n L K a x.
  subst x.
  intros Lower Upper L32 K32.
  intros Equal1 Equal2.
  unfold P_MultisetReorder_1_.
  intros w w32.
  unfold P_Equal_4_ in *.
  unfold P_Equal_3_ in *.
  unfold P_Equal_2_ in *.
  unfold P_Equal_1_ in *.
  unfold shift_sint32 in *.

  assert(MN: (A_Count.L_Count_1_ K a n (1 + n) w = A_Count.L_Count_1_ L a m (1 + m) w)%Z).
  {
    rewrite <- A_Count.Q_Count_Equal with (i:=(m)%Z) (t_1:=L); auto with zarith.
    now replace (m + (1 + n) - n)%Z with (1+m)%Z by lia.
  }
  rewrite <- A_Count.Q_Count_Union with (i_1:=n); auto with zarith.
  symmetry.
  rewrite <- A_Count.Q_Count_Union with (i_1:=(1+m)%Z); auto with zarith.
  enough(A_Count.L_Count_1_ L a (1 + m) (1 + n) w = A_Count.L_Count_1_ K a m n w)%Z by lia.
  symmetry.
  rewrite <- A_Count.Q_Count_Equal with (i:=(1+m)%Z) (t_1:=L); auto with zarith.
  now replace (1 + m + n - m)%Z with (1+n)%Z by lia.

Qed.

Goal typed_external_lemma_CircularShift_StrictLowerBound.
Hint CircularShift_StrictLowerBound,property.
Proof.
  Require Import Psatz.
  intros m n L K a.
  intros x x_1 x_2 x_3.
  subst x x_1 x_2 x_3.
  intros LChunk KChunk Lam Kan.
  intros Equal1 Equal2 StrictLower.
  unfold P_StrictLowerBound_1_ in *.
  intros.
  unfold P_Equal_4_ in *.
  unfold P_Equal_3_ in *.
  unfold P_Equal_2_ in *.
  unfold P_Equal_1_ in *.

  unfold shift_sint32 in *.

  replace m with (m + 0)%Z by lia.
  rewrite <- shift_associative.
  rewrite <- Equal2; auto with zarith.

  replace i with ((1 + m) + (i - (1 + m)))%Z by lia.
  rewrite <- shift_associative.
  rewrite <- Equal1; auto with zarith.

  rewrite shift_associative.
  rewrite shift_associative.

  replace (n + 0)%Z with n by lia.
  replace (m + (i - (1 + m)))%Z with (i - 1)%Z by lia.
  apply StrictLower; auto with zarith.
Qed.

Goal typed_external_lemma_CountInd_Count.
Hint CountInd_Count,property.
Proof.
  Require Import Psatz.
  intros v n L a LChunk IV.
  assert (n <= 0 \/ n > 0)%Z by lia.
  destruct H as [le|gt].
  {
   assert (Nil: (L_Count_2_ L a n v = 0)%Z) by now apply A_Count.Q_Count_Empty.
   rewrite Nil.
   apply Q_Nil; auto with zarith.
  }
  apply natlike_rec3 with (z := n); auto with zarith.
  + assert (Nil: (L_Count_2_ L a 0 v = 0)%Z) by now apply A_Count.Q_Count_Empty.
    rewrite Nil.
    apply Q_Nil; auto with zarith.
  + intros z zNN IHz.
    replace (Z.pred z) with (z - 1)%Z in * by lia.
    assert (L.[shift a (z - 1)] <> v \/ L.[shift a (z - 1)] = v) by lia.
    destruct H as [Ne|Eq].
    - assert (Miss: L_Count_2_ L a (z - 1) v = L_Count_2_ L a z v) by
      (apply A_Count.Q_Count_Miss; auto with zarith).
      rewrite <- Miss.
      apply Q_Miss; auto with zarith.
    - assert (Hit: (1 + L_Count_2_ L a (z - 1) v = L_Count_2_ L a z v)%Z) by
      (rewrite <- Eq in *; apply A_Count.Q_Count_Hit; auto with zarith).
      rewrite <- Hit.
      rewrite <- Eq in *.
      apply Q_Hit; auto with zarith.
Qed.

Goal typed_external_lemma_CountInd_Inverse.
Hint CountInd_Inverse,property.
Proof.
  Require Import Psatz. 
  intros v m n.
  intros L a.
  intros.
  inversion H0; subst; intuition.
  right.
  left.
  split; auto.
  split; auto.
  replace x with x0 in * by lia.
  now replace (1 + i - 1)%Z with i by lia.
Qed.

Goal typed_external_lemma_CountInd_NonNegative.
Hint CountInd_NonNegative,property.
Proof.
  intros v n sum L a L32 v32 Count.
  induction Count; auto with zarith.
Qed.

Goal typed_external_lemma_CountInd_Unchanged.
Hint CountInd_Unchanged,property.
Proof.
  Require Import Psatz.
  intros v n sum.
  intros K L a KChunk LChunk.
  intros IV U.
  split.
  {
    intro CK.
    induction CK as [v i K a | v i sum K a | v i sum K].
    + now apply Q_Nil.
    + subst x.
      assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]) by 
        (apply U; auto with zarith).
      apply Q_Hit; auto with zarith.
      apply IHCK; auto with zarith.
      apply A_UnchangedLemmas.Q_Unchanged_Shrink with  (i_3:=0%Z) (i_2:=i) ; auto with zarith.
    + subst x.
      apply Q_Miss; auto with zarith.
      - assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]) 
          by  (apply U; auto with zarith).
        now rewrite LK.
      - apply IHCK; auto with zarith.
        apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=0%Z) (i_2:=i); auto with zarith.
  }
  intro CL.
  induction CL as [v i L | v i sum L a | v i sum L].
  + now apply Q_Nil.
  + subst x.
    assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]) 
          by  (apply U; auto with zarith).
    apply Q_Hit; auto with zarith.
    apply IHCL; auto with zarith.
    apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=0%Z) (i_2:=i); auto with zarith.
  + subst x.
    assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]) 
          by  (apply U; auto with zarith).
    apply Q_Miss; auto with zarith.
    apply IHCL; auto with zarith.
    apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=0%Z) (i_2:=i); auto with zarith.
Qed.

Goal typed_external_lemma_CountNotEqual_AllEqual.
Hint CountNotEqual_AllEqual,property.
Proof.
  Require Import Psatz.
  intros v m n L a mGE mLT LChunk V.
  remember (n-m)%Z as p.
  replace n with (m+p)%Z in * by lia.
  assert(pNN: (0 <= p)%Z) by lia.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    replace (m+0)%Z with m by lia.
    intros All.
    rewrite A_CountNotEqual.Q_CountNotEqual_Empty; auto with zarith.
  }
  {
    intros z zNN IHz All.
    replace (m + Z.succ z)%Z with (1+(m+z))%Z in * by auto with zarith.
    rewrite A_CountNotEqual.Q_CountNotEqual_Miss; auto with zarith.
    apply IHz; auto with zarith.
    unfold P_AllEqual_1_; auto with zarith.
  }
Qed.

Goal typed_external_lemma_CountNotEqual_Count.
Hint CountNotEqual_Count,property.
Proof.
  Require Import Psatz.
  intros v m n L a mn_le VChunk V.

  remember (n - m)%Z as p.
  replace n with (m + p)%Z in * by lia.
  assert(pNN: (0 <= p)%Z) by lia.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    rewrite Q_CountNotEqual_Empty; auto with zarith.
    rewrite A_Count.Q_Count_Empty; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (m+Z.succ z)%Z with (1+(m+z))%Z by auto with zarith.
    assert (X: (1+(m+z)-1 = m+z)%Z) by lia.
    assert(eq_neq: L.[ (shift_sint32 a (m+z)%Z) ] = v \/ L.[ (shift_sint32 a (m+z)%Z) ] <> v) by lia.
    destruct eq_neq as [eq|neq].
    - rewrite Q_CountNotEqual_Miss; auto with zarith.
      rewrite <- A_Count.Q_Count_Hit; auto with zarith.
      + now rewrite X; lia.
      + now rewrite X.
    - rewrite <- Q_CountNotEqual_Hit; auto with zarith.
      rewrite <- A_Count.Q_Count_Miss; auto with zarith.
      + now rewrite X; lia.
      + now rewrite X.
  }
Qed.

Goal typed_external_lemma_CountNotEqual_Decrement.
Hint CountNotEqual_Decrement,property.
Proof.
  Require Import Psatz.
  intros v m n L a.
  intros mNN mLess V.
  remember (m + L_FindNotEqual_1_ L a m n v)%Z as x.

  assert(Union1: (L_CountNotEqual_1_ L a m n v = 
                 L_CountNotEqual_1_ L a m x v + L_CountNotEqual_1_ L a x n v)%Z).
  {
    rewrite <- A_CountNotEqual.Q_CountNotEqual_Union with (i_1:=x); auto with zarith.
    - enough (0 <= L_FindNotEqual_1_ L a m n v)%Z; auto with zarith.
      apply A_FindNotEqual.Q_FindNotEqual_Lower; by auto with zarith.
    - enough (m + L_FindNotEqual_1_ L a m n v <= n)%Z; auto with zarith.
      apply A_FindNotEqual.Q_FindNotEqual_Upper; by auto with zarith.
  }

  assert(Zero: (L_CountNotEqual_1_ L a m x v = 0)%Z).
  {
    subst x.
    rewrite Q_CountNotEqual_Zero; auto with zarith.
  }


  assert(Union2: (L_CountNotEqual_1_ L a 0 n v = 
             L_CountNotEqual_1_ L a 0 m v + L_CountNotEqual_1_ L a m n v)%Z).
  {
    rewrite <- A_CountNotEqual.Q_CountNotEqual_Union with (i_1 := m); auto with zarith.
  }

  rewrite Union2.
  
  auto with zarith.
  subst x.
  lia.
  rewrite X.
  rewrite <- A_CountNotEqual.Q_CountNotEqual_Hit; auto with zarith.
  rewrite A_CountNotEqual.Q_CountNotEqual_Empty; auto with zarith.
  rewrite Q_CountNotEqual_AllEqual; auto with zarith.
  + rewrite Heqx.
    enough(0 <= L_FindNotEqual_1_ L a (1 + m) n v)%Z; auto with zarith.
    apply A_FindNotEqual.Q_FindNotEqual_Lower; auto with zarith.
  + rewrite Heqx.
    apply A_FindNotEqual.Q_FindNotEqual_ResultAllEqual; auto with zarith.
Qed.

Goal typed_external_lemma_CountNotEqual_Increasing.
Hint CountNotEqual_Increasing,property.
Proof.
  Require Import Psatz.
  intros v k m n L a.
  intros MK KN LChunk V.

  remember (n-k)%Z as p.
  replace n with (k + p)%Z by lia.
  assert (pNN: (0 <= p)%Z) by lia.
  apply natlike_rec2 with (z := p); auto with zarith.
  {
    now replace (k+0)%Z with k by lia.
  }
  {
    intros z zNN IHz.
    replace (k + Z.succ z)%Z with (1+(k+z))%Z in * by lia.
    assert (eq_neq: L.[ shift a (k+z)] = v \/ L.[ shift a (k+z)] <> v) by lia.
    destruct eq_neq as [eq|neq].
    - rewrite Q_CountNotEqual_Miss; auto with zarith.
    - rewrite <- Q_CountNotEqual_Hit; auto with zarith.
  }
Qed.

Goal typed_external_lemma_CountNotEqual_Lower.
Hint CountNotEqual_Lower,property.
Proof.
  Require Import Psatz.
  intros v m n L a MN LChunk V.

  remember (n-m)%Z as p.
  replace n with (m+p)%Z in * by lia.
  assert(pNN: (0 <= p)%Z) by lia.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    rewrite Q_CountNotEqual_Empty; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (m + Z.succ z)%Z with (1 + (m+z))%Z by lia.
    assert(neq_eq: (L .[ shift_sint32 a (m + z)] <> v \/ L .[ shift_sint32 a (m + z)] = v)%Z) by lia.
    destruct neq_eq as [neq|eq].
    - rewrite <- Q_CountNotEqual_Hit; auto with zarith.
    - rewrite    Q_CountNotEqual_Miss; auto with zarith.
  }
Qed.

Goal typed_external_lemma_CountNotEqual_Unchanged.
Hint CountNotEqual_Unchanged,property.
Proof.
  Require Import Psatz.
  intros v m  n K L a KChunk LChunk V Unchanged.
  revert Unchanged.
  assert(lt_ge: (n < m \/ m <= n)%Z) by lia.
  destruct lt_ge as [lt|ge].
  {
    repeat rewrite Q_CountNotEqual_Empty; auto with zarith.
  }
  {
    remember (n - m)%Z as p.
    replace n with (m + p)%Z in * by lia.
    assert(pNN: (0 <= p)%Z) by lia.
    apply natlike_rec2 with (z:=p); auto with zarith.
    {
      repeat rewrite Q_CountNotEqual_Empty; auto with zarith.
    }
    {
      intros z zNN IHz.
      replace (m + Z.succ z)%Z with (1+(m+z))%Z by lia.
      intros Unchanged.

      assert(eq_neq: K.[ (shift_sint32 a (m+z)%Z) ] = v \/ K.[ (shift_sint32 a (m+z)%Z) ] <> v) by lia.
      destruct eq_neq as [eq|neq].
      - repeat rewrite Q_CountNotEqual_Miss; auto with zarith.
        + rewrite IHz; auto with zarith.
          apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=m%Z) (i_2:=(1+(m+z))%Z); auto with zarith.
        + rewrite <- eq; auto with zarith.
      - repeat rewrite <- Q_CountNotEqual_Hit; auto with zarith.
        + rewrite IHz; auto with zarith.
          apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=m%Z) (i_2:=(1+(m+z))%Z); auto with zarith.
        + rewrite Unchanged; auto with zarith.
    }
  }
Qed.

Goal typed_external_lemma_CountNotEqual_Union.
Hint CountNotEqual_Union,property.
Proof.
  Require Import Psatz.
  intros v k m n L a.
  intros kLower mLower nLower.
  intros L32 v32.

  replace n with (m + (n-m))%Z by lia.
  apply natlike_rec2 with (z := (n - m)%Z); auto with zarith.
  {
    rewrite Zplus_0_r.
    rewrite Q_CountNotEqual_Empty; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (m + Z.succ z)%Z with (1+(m+z))%Z in * by lia.

    assert (X: v = L.[ shift a (m+z)] \/ v <> L.[ shift a (m+z)]) by lia.
    destruct X as [eq|neq].
    - repeat rewrite Q_CountNotEqual_Miss; auto with zarith.
    - repeat rewrite <- Q_CountNotEqual_Hit; auto with zarith.
  }
Qed.

Goal typed_external_lemma_CountNotEqual_Upper.
Hint CountNotEqual_Upper,property.
Proof.
  Require Import Psatz.
  intros v m n L a MN LChunk V.

  remember (n-m)%Z as p.
  replace n with (m+p)%Z in * by lia.
  assert(pNN: (0 <= p)%Z) by lia.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    rewrite Q_CountNotEqual_Empty; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (m + Z.succ z)%Z with (1 + (m+z))%Z by lia.
    assert(neq_eq: (L .[ shift_sint32 a (m + z)] <> v \/ L .[ shift_sint32 a (m + z)] = v)%Z) by lia.
    destruct neq_eq as [neq|eq].
    - rewrite <- Q_CountNotEqual_Hit; auto with zarith.
    - rewrite    Q_CountNotEqual_Miss; auto with zarith.
  }
Qed.

Goal typed_external_lemma_Count_Bounds.
Hint Count_Bounds,property.
Proof.
  Require Import Psatz.
  intros v m n L a Count mNN mn LChunk V.
  subst Count.

  remember (n-m)%Z as p.
  replace n with (m + p)%Z by lia.
  apply natlike_rec2 with (z := p); auto with zarith.
  {
    rewrite Q_Count_Empty; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (m + Z.succ z)%Z with (1+(m+z))%Z in * by lia.
    rewrite <- Q_Count_One; auto with zarith.
    enough (0 <= L_Count_1_ L a (m + z) (1 + (m + z)) v <= 1)%Z by lia.
    apply Q_Count_Single_Bounds; auto with zarith.
  }
Qed.

Goal typed_external_lemma_Count_Equal.
Hint Count_Equal,property.
Proof.
  Require Import Psatz.
  intros v m n p L K a P Q LChunk KChunk V Equal.
  remember (n-m)%Z as k.
  replace n with (m + k)%Z in * by lia.
  assert(kNN: (0 <= k)%Z) by lia.
  replace (p + (m + k) - m)%Z with (p+k)%Z by lia.
  revert Equal.

  apply natlike_rec2 with (z := k); auto with zarith.
  {
    repeat rewrite Q_Count_Empty; auto with zarith.
  }
  {
    intros z zNN IHz Equal.
    replace (m + Z.succ z)%Z with (1 + (m+z))%Z in * by lia.
    replace (p + Z.succ z)%Z with (1 + (p+z))%Z by lia.
    assert(Y: P_Equal_4_ L K a m (m + z) p).
    {
      unfold P_Equal_4_ in *.
      unfold P_Equal_3_ in *.
      unfold P_Equal_2_ in *.
      unfold P_Equal_1_ in *.
      intros.
      rewrite Equal; auto with zarith.
    }

    rewrite <- Q_Count_One; auto with zarith.
    symmetry.
    rewrite <- Q_Count_One; auto with zarith.
    rewrite <- IHz; auto with zarith.

    enough(L_Count_1_ K a (m + z) (1 + (m + z)) v = L_Count_1_ L a (p + z) (1 + (p + z)) v)%Z by lia.
    rewrite Q_Count_Single with (i_1:=(p+z)%Z) (a_1:=a) (t:=L); auto with zarith.
    rewrite <- shift_associative.
    rewrite Equal; auto with zarith.
    rewrite <- shift_associative; auto with zarith.
  }
Qed.

Goal typed_external_lemma_Count_Increasing.
Hint Count_Increasing,property.
Proof.
  Require Import Psatz.
  intros v m n p.
  intros.

  replace p with (n + (p-n))%Z by lia.
  apply natlike_rec2 with (z := (p - n)%Z); auto with zarith.
  {
    replace (n+0)%Z with n by lia.
    lia.
  }
  {
    intros z zNN IHz.
    replace (n + Z.succ z)%Z with (1+(n+z))%Z in * by lia.
    apply  Z.ge_le.
    rewrite <- Q_Count_One; auto with zarith.
    enough (L_Count_1_ t a (n + z) (1 + (n + z)) v >= 0)%Z by lia.
    apply  Z.le_ge.
    apply Q_Count_Single_Bounds; auto with zarith.
  }
Qed.

Goal typed_external_lemma_Count_Shift.
Hint Count_Shift,property.
Proof.
  Require Import Psatz.
  intros v m n L a mNN nNN LChunk V.
  replace (n+m)%Z with (m+n)%Z by lia.

  apply natlike_rec2 with (z := n); auto with zarith.
  {
    repeat rewrite Q_Count_Empty; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (Z.succ z) with (1 + z)%Z by auto with zarith.
    replace (m + (1+z))%Z with (1 + (m+z))%Z by lia.
    rewrite <- Q_Count_One; auto with zarith.
    symmetry.
    rewrite <- Q_Count_One; auto with zarith.
    unfold shift_sint32 in *.
    rewrite <- IHz.
    enough (L_Count_1_ L (shift a m) z (1 + z) v = L_Count_1_ L a (m+z) (1 + (m+z)) v)%Z by lia.
    rewrite <- Q_Count_Single_Shift; auto with zarith.
    unfold shift_sint32 in *.
    remember (L.[shift a (m+z)]) as amz.
    assert (X: amz = v \/ amz <> v) by lia.
    destruct X as [eq|neq].
    {
      rewrite shift_associative.
      rewrite <- Q_Count_Hit; auto with zarith.
      - rewrite Q_Count_Empty; auto with zarith.
        + rewrite <- Q_Count_Hit; auto with zarith.
          rewrite Q_Count_Empty; auto with zarith.
          replace (1 + (m + z) - 1)%Z with (m+z)%Z by lia.
          unfold shift_sint32; lia.
      - rewrite shift_associative.
        replace (m + z + (1 - 1))%Z with (m+z)%Z by lia.
        lia.
    }
    {
      rewrite shift_associative.
      rewrite <- Q_Count_Miss; auto with zarith.
      - rewrite Q_Count_Empty; auto with zarith.
        rewrite <- Q_Count_Miss; auto with zarith.
        + rewrite Q_Count_Empty; auto with zarith.
        + replace (1 + (m + z) - 1)%Z with (m+z)%Z by lia.
          unfold shift_sint32; lia.
      - rewrite shift_associative.
        replace (m + z + (1 - 1))%Z with (m+z)%Z by lia.
        lia.
    }
  }
Qed.

Goal typed_external_lemma_Count_Single_Shift.
Hint Count_Single_Shift,property.
Proof.
  intros v n L a nNN L32 v32.
  rewrite <- Q_Count_One; auto with zarith.
Qed.

Goal typed_external_lemma_Count_SomeEqual.
Hint Count_SomeEqual,property.
Proof.
  Require Import Psatz.
  intros v m n L a.
  intros NN Less Count LChunk V.
  revert Count.

  remember (n - m)%Z as p.
  assert (Pos: (0 < p)%Z) by lia.

  replace n with (m + p)%Z in * by lia.
  apply natlike_rec3 with (z := p); auto with zarith.
  {
    intros.
    rewrite A_Count.Q_Count_Empty in Count; auto with zarith.
    lia.
  }
  {
    intros z zPos IHz IH.

    replace (Z.pred z) with (z-1)%Z in * by lia.
    replace (m + (z - 1))%Z with (m + z - 1)%Z in * by lia.

    assert (Value: L.[ shift a (m + z - 1)] = v \/ L.[ shift a (m + z - 1)] <> v) by lia.
    destruct Value as [eq|neq].
    {
      unfold P_SomeEqual_1_.
      exists (m + z - 1)%Z.
      split; auto with zarith.
    }
    {
      rewrite <- A_Count.Q_Count_Miss in IH; auto with zarith.
      cut (P_SomeEqual_1_ L a m (m + z - 1) v).
      + unfold P_SomeEqual_1_ .
        intros X.
        destruct X as [k [P Q]].
        exists k.
        split; auto with zarith.
      + now apply IHz.
    }
  }
Qed.

Goal typed_external_lemma_Count_Unchanged.
Hint Count_Unchanged,property.
Proof.
  Require Import Psatz.
  intros v m n L K a LChunk KChunk V Unchanged.

  assert(X: (n <= m \/ n > m)%Z) by lia.
  destruct X as [leq|greater].
  {
    rewrite Q_Count_Empty; auto with zarith.
    rewrite Q_Count_Empty; auto with zarith.
  }
  {
    pose (p := (n - m)%Z).
    replace n with (m + p)%Z in * by (subst p; auto with zarith).
    assert(Pos: (p > 0)%Z) by lia.
    revert Unchanged.

    apply natlike_rec2 with (z := p); auto with zarith.
    {
      intros.
      rewrite Q_Count_Empty; auto with zarith.
      rewrite Q_Count_Empty; auto with zarith.
    }
    {
      intros z zPos IHz Unchanged.
      replace (m + Z.succ z)%Z with (1+(m + z))%Z in * by lia.
      rewrite <- Q_Count_One; auto with zarith.
      symmetry.
      rewrite <- Q_Count_One; auto with zarith.
      rewrite <- IHz.
      - rewrite Q_Count_Single with (i_1:=(m+z)%Z) (t:=L) (a_1:=a); auto with zarith.
      - apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=m) (i_2:=(1+(m+z))%Z); auto with zarith.
    }
  }
Qed.

Goal typed_external_lemma_Count_Union.
Hint Count_Union,property.
Proof.
  Require Import Psatz.
  intros v k m n L a.
  intros.

  replace n with (m + (n-m))%Z by lia.
  apply natlike_rec2 with (z := (n - m)%Z); auto with zarith.
  {
    rewrite Zplus_0_r.
    rewrite Q_Count_Empty; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (m + Z.succ z)%Z with (1+(m+z))%Z in * by lia.
    rewrite <- Q_Count_One; auto with zarith.
    symmetry.
    rewrite <- Q_Count_One; auto with zarith.
  }
Qed.

Goal typed_external_lemma_Difference_Zero.
Hint Difference_Zero,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_lemma_FindNotEqual_AllEqual.
Hint FindNotEqual_AllEqual,property.
Proof.
  Require Import Psatz.
  intros v m n L a MN V All.

  remember (n-m)%Z as p.
  replace n with (p+m)%Z in * by lia.
  assert(pNN: (0 <= p)%Z) by lia.
  revert MN All.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    intros.
    replace (0+m)%Z with m by lia.
    rewrite Q_FindNotEqual_Empty; auto with zarith.
  }
  {
    intros z zNN IHz. intros.
    replace (Z.succ z + m)%Z with (1+(z+m))%Z in * by lia.
    rewrite Q_FindNotEqual_MissMiss; auto with zarith.
    apply IHz; auto with zarith.
    unfold P_AllEqual_1_.
    intros; auto with zarith.
  }
Qed.

Goal typed_external_lemma_FindNotEqual_Extend.
Hint FindNotEqual_Extend,property.
Proof.
  Require Import Psatz.
  intros v k m n L a ak Neq Found m0 mn VChunk V akChunk.
  subst ak.
  remember (n - m)%Z as p.
  replace n with (m + p)%Z in * by (subst p; auto with zarith).
  assert(pPos: (p > 0)%Z) by auto with zarith.
  revert mn.

  apply natlike_rec2 with (z := p); auto with zarith.
  intros z zNN IHz.
  intros.
  replace (m + (Z.succ z))%Z with (1+(m+z))%Z in * by lia.
  assert(less_equal: (k < m+z \/ k = m+z)%Z) by lia.
  destruct less_equal as [less|equal].
  - rewrite Q_FindNotEqual_Hit; auto with zarith.
  - rewrite equal in *.
    rewrite Q_FindNotEqual_MissHit; auto with zarith.
Qed.

Goal typed_external_lemma_FindNotEqual_Increasing.
Hint FindNotEqual_Increasing,property.
Proof.
  Require Import Psatz.
  intros v k m n L a Lower Upper L32 V.

  remember (n-m)%Z as p.
  assert(pNN: (0 <= p)%Z) by lia.
  replace n with (m+p)%Z in * by lia.
  revert Upper.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    intros Upper.
    rewrite Zplus_0_r in *.
    repeat rewrite Q_FindNotEqual_Empty; auto with zarith.
  }
  {
    intros z zNN IHz. intros.
    replace (m + Z.succ z)%Z with (1+(m+z))%Z in * by lia.
    assert(X: (L_FindNotEqual_1_ L a m (m+z) v <= L_FindNotEqual_1_ L a m (1+(m+z)) v)%Z) by
      (apply Q_FindNotEqual_WeaklyIncreasing; auto with zarith).
    assert(le_eq: (k <= m+z \/ k = 1+(m+z))%Z) by lia.
    destruct le_eq as [le|eq].
    - assert(Y: (L_FindNotEqual_1_ L a m k v <= L_FindNotEqual_1_ L a m (m+z) v)%Z) by 
        (apply IHz; auto with zarith).
      lia.
    - rewrite eq; lia.
  }
Qed.

Goal typed_external_lemma_FindNotEqual_Limit.
Hint FindNotEqual_Limit,property.
Proof.
  Require Import Psatz.
  intros v k m n L a ak.
  intros Found Lower Upper VChunk V akChunk.
  subst ak.

  remember (n-m)%Z as p.
  replace n with (m+p)%Z in * by lia.
  assert (pPos : (0 < p)%Z) by lia.
  revert Upper.

  apply natlike_rec2 with (z := p); auto with zarith.
  intros z zNN IHz Upper.
  replace (m+Z.succ z)%Z with (1+(m+z))%Z in * by lia.
  assert(less_equal: (k < m+z \/ k = m+z)%Z) by lia.
  destruct less_equal as [less|equal].
  - rewrite Q_FindNotEqual_Hit; auto with zarith.
  - rewrite equal in *.
    clear IHz Upper equal.
    assert(U: (m+L_FindNotEqual_1_ L a m (m+z) v <= m+z)%Z).
    + apply Q_FindNotEqual_Upper; auto with zarith.
    + assert(hit_miss: (L_FindNotEqual_1_ L a m (m+z) v < z \/ L_FindNotEqual_1_ L a m (m+z) v = z)%Z) 
        by lia.
      destruct hit_miss as [hit|miss].
      * rewrite Q_FindNotEqual_Hit; auto with zarith.
      * rewrite Q_FindNotEqual_MissHit; auto with zarith.
Qed.

Goal typed_external_lemma_FindNotEqual_Unchanged.
Hint FindNotEqual_Unchanged,property.
Proof.
  Require Import Psatz.
  intros v m n K L a KChunk VChunk V.
  remember (n-m)%Z as p.
  replace n with (m+p)%Z by lia.
  assert(nonpos_pos: (p <= 0 \/ 0 < p)%Z) by lia.
  destruct nonpos_pos as [nonpos|pos].
  {
    repeat rewrite Q_FindNotEqual_Empty; auto with zarith.
  }
  {
    apply natlike_rec2 with (z:=p); auto with zarith.
    {
      repeat rewrite Q_FindNotEqual_Empty; auto with zarith.
    }
    {
      intros z zNN IHz.
      intro.
      replace (m + Z.succ z)%Z with (1+(m+z))%Z in * by lia.
      replace (Z.succ z) with (1+z)%Z in * by lia.

      assert(Unchanged: P_Unchanged_1_ K L a m (m + z)).
      {
        apply A_UnchangedLemmas.Q_Unchanged_Shrink 
                with (i_2:=(1 + (m + z))%Z) (i_3:=m); auto with zarith.
      }
      assert (found_notfound: (m + L_FindNotEqual_1_ K a m (m + z) v < m + z  \/
                               m + L_FindNotEqual_1_ K a m (m + z) v = m + z)%Z).
      {
        assert(m + L_FindNotEqual_1_ K a m (m + z) v <= m+z)%Z.
        - apply Q_FindNotEqual_Upper; auto with zarith.
        - lia.
      }
      assert(eq_neq: K.[ (shift_sint32 a (m+z)%Z) ] = v \/ K.[ (shift_sint32 a (m+z)%Z) ] <> v) by lia.

      destruct found_notfound as [found|notfound]; auto with zarith.
      {
        destruct eq_neq as [eq|neq].
        {
          assert(L .[ shift_sint32 a (m + z)] = v) by (rewrite H; auto with zarith).
          repeat rewrite Q_FindNotEqual_Hit; auto with zarith.
          rewrite <- IHz; auto with zarith.
        }
        {
          repeat rewrite Q_FindNotEqual_Hit; auto with zarith.
          rewrite <- IHz; auto with zarith.
        }
      }
      {
        destruct eq_neq as [eq|neq].
        {
          assert(L .[ shift_sint32 a (m + z)] = v) by (rewrite H; auto with zarith).
          enough(m + L_FindNotEqual_1_ K a m (1 + (m + z)) v =
                 m + L_FindNotEqual_1_ L a m (1 + (m + z)) v)%Z by lia.
          rewrite Q_FindNotEqual_MissMiss with (t:=K) (a:=a) (i_2:=v) (i_1:=m%Z); auto with zarith.
          rewrite Q_FindNotEqual_MissMiss with (t:=L) (a:=a) (i_2:=v) (i_1:=m%Z); auto with zarith.
          rewrite <- IHz; auto with zarith.
        }
        {
          enough(m + L_FindNotEqual_1_ K a m (1 + (m + z)) v =
                 m + L_FindNotEqual_1_ L a m (1 + (m + z)) v)%Z by lia.
          rewrite Q_FindNotEqual_MissHit with (t:=K) (a:=a) (i_2:=v) (i_1:=m%Z); auto with zarith.
          symmetry.
          rewrite Q_FindNotEqual_MissHit with (t:=L) (a:=a) (i_2:=v) (i_1:=m%Z); auto with zarith.
          - rewrite H; auto with zarith.
          - rewrite <- IHz; auto with zarith.
        }
      }
    }
  }
Qed.

Goal typed_external_lemma_Find_Extend.
Hint Find_Extend,property.
Proof.
  Require Import Psatz.
  intros v k m n L a ak akv Found kLower kUpper VChunk V AK.
  subst ak.
  pose (p := (n - m)%Z).
  replace n with (m + p)%Z in * by (subst p; auto with zarith).
  assert(pPos: (p > 0)%Z) by auto with zarith.
  revert kUpper.

  apply natlike_rec2 with (z := p); auto with zarith.
  intros z zNN IHz.
  intros.
  replace (m + (Z.succ z))%Z with (1+(m+z))%Z in * by lia.
  assert(less_equal: (k < m+z \/ k = m+z)%Z) by lia.
  destruct less_equal as [less|equal].
  - rewrite Q_Find_Hit; auto with zarith.
  - rewrite equal in *.
    rewrite Q_Find_MissHit; auto with zarith.
Qed.

Goal typed_external_lemma_Find_Increasing.
Hint Find_Increasing,property.
Proof.
  Require Import Psatz.
  intros v k m n L a Lower Upper V.

  remember (n-m)%Z as p.
  assert(pNN: (0 <= p)%Z) by lia.
  replace n with (m+p)%Z in * by lia.
  revert Upper.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    intros.
    rewrite Zplus_0_r in *.
    repeat rewrite Q_Find_Empty; auto with zarith.
  }
  {
    intros z zNN IHz. intros.
    replace (m + Z.succ z)%Z with (1+(m+z))%Z in * by lia.
    assert(X: (L_Find_1_ L a m (m+z) v <= L_Find_1_ L a m (1+(m+z)) v)%Z) by
      (apply Q_Find_WeaklyIncreasing; auto with zarith).
    assert(le_eq: (k <= m+z \/ k = 1+(m+z))%Z) by lia.
    destruct le_eq as [le|eq].
    - assert(Y: (L_Find_1_ L a m k v <= L_Find_1_ L a m (m+z) v)%Z) by (apply IHz; auto with zarith).
      lia.
    - rewrite eq; lia.
  }
Qed.

Goal typed_external_lemma_Find_Limit.
Hint Find_Limit,property.
Proof.
  Require Import Psatz.
  intros v k m n L a ak.
  intros Found Lower Upper VChunk V akChu.
  subst ak.

  remember (n-m)%Z as p.
  replace n with (m+p)%Z in * by lia.
  assert (pPos : (0 < p)%Z) by lia.
  revert Upper.

  apply natlike_rec2 with (z := p); auto with zarith.
  intros z zNN IHz.
  intros.
  replace (m+Z.succ z)%Z with (1+(m+z))%Z in * by lia.
  assert(less_equal: (k < m+z \/ k = m+z)%Z) by lia.
  destruct less_equal as [less|equal].
  - rewrite Q_Find_Hit; auto with zarith.
  - rewrite equal in *.
    clear IHz Upper equal.
    assert(U: (m+L_Find_1_ L a m (m+z) v <= m+z)%Z).
    + apply Q_Find_Upper; auto with zarith.
    + assert(hit_miss: (L_Find_1_ L a m (m+z) v < z \/ L_Find_1_ L a m (m+z) v = z)%Z) by lia.
      destruct hit_miss as [hit|miss].
      * rewrite Q_Find_Hit; auto with zarith.
      * rewrite Q_Find_MissHit; auto with zarith.
Qed.

Goal typed_external_lemma_Find_None.
Hint Find_None,property.
Proof.
  intros v n L a N V.
  assert(N' := N).
  revert N.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros.
    rewrite A_Find.Q_Find_Empty; auto with zarith.
  }
  {
    intros z Z IHz.
    intros.
    replace (Z.succ z) with (1+z)%Z in * by auto with zarith.
    assert(X: (forall (i: int), 0 <= i <= z -> L .[ shift_sint32 a i] <> v)%Z).
    {
      intuition.
      unfold P_HasValue_2_ in H.
      unfold P_HasValue_1_ in H.
      apply H.
      exists i%Z; auto with zarith.
    }

    rewrite <- A_Find.Q_Find_Miss_Miss; auto with zarith.
    apply IHz; auto with zarith.
    intuition.
    unfold P_HasValue_2_ in H0.
    unfold P_HasValue_1_ in H0.
    destruct H0 as [j [A B]].
    apply X with (i:=j); auto with zarith.
  }
Qed.

Goal typed_external_lemma_Find_NoneEqual.
Hint Find_NoneEqual,property.
Proof.
  Require Import Psatz.
  intros v m n L a MN VChunk V None.

  remember (n-m)%Z as p.
  replace n with (p+m)%Z in * by lia.
  assert(pNN: (0 <= p)%Z) by lia.
  revert MN None.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    intros.
    replace (0+m)%Z with m by lia.
    rewrite Q_Find_Empty; auto with zarith.
  }
  {
    intros z zNN IHz. intros.
    replace (Z.succ z + m)%Z with (1+(z+m))%Z in * by lia.
    rewrite Q_Find_MissMiss; auto with zarith.
    rewrite IHz; auto with zarith.
    unfold P_NoneEqual_1_.
    intros.
    apply None; auto with zarith.
  }
Qed.

Goal typed_external_lemma_HeapParent_Zero.
Hint HeapParent_Zero,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_lemma_Heap_Maximum.
Hint Heap_Maximum,property.
Proof.
  Require Import Psatz.
  intros n L a Pos LChunk.
  assert(Pos1:=Pos).
  revert Pos.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros; lia. 
  }
  {
    intros z zNN IHz.
    intros.
    replace (Z.succ z) with (1+z)%Z in * by lia.
    assert(X: P_Heap L a z).
    {
      unfold P_Heap.
      intros.
      apply H; auto with zarith.
    }
    assert(zero_pos: z = 0 \/ 0 < z) by lia.
    destruct zero_pos as [zero|pos].
    {
      replace (1+z) with 1 in * by lia.
      unfold P_MaxElement.
      split; auto with zarith.
      split; auto with zarith.
      unfold A_ArrayBounds.P_UpperBound_2_.
      unfold A_ArrayBounds.P_UpperBound_1_.
      intros.
      now replace i with 0 by lia.
    }
    {
      assert(Y: P_MaxElement L a z 0) by (apply IHz; auto with zarith).
      unfold P_MaxElement.
      split; auto with zarith.
      split; auto with zarith.
      unfold A_ArrayBounds.P_UpperBound_2_.
      unfold A_ArrayBounds.P_UpperBound_1_.
      intros.
      assert(less_equal: i < z \/ i = z) by lia.
      destruct less_equal as [less|equal].
      - apply IHz; auto with zarith.
      - rewrite equal in *.
        assert(A: (L.[shift a z] <= L.[shift a (L_HeapParent  z)])%Z) by
          (apply H; auto with zarith).
        assert(B: (L.[shift a (L_HeapParent  z)] <= L.[shift a 0])%Z).
        {
          apply IHz; auto with zarith.
          - unfold L_HeapParent.
            apply cdiv_lower; lia.
          - unfold L_HeapParent.
            enough (Cdiv (z-1) 2 <= z-1)%Z; auto with zarith.
            apply cdiv_upper; lia.
        }
        unfold Compound.shift_sint32; lia.
     }
  }
Qed.

Goal typed_external_lemma_Heap_Unchanged.
Hint Heap_Unchanged,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_lemma_Increasing_Equal.
Hint Increasing_Equal,property.
Proof.
 Require Import Psatz.
 intros m n p L K a x LChunk KChunk Increasing Equal.
 subst x.
 unfold P_Increasing_1_.
 intros i j; intros IJ H HH.

 replace i with ((p + m) + (i - p - m))%Z by lia.
 rewrite <- shift_associative.
 rewrite <- Equal; auto with zarith.

 replace j with ((p + m) + (j - p - m))%Z by lia.
 rewrite <- shift_associative.
 rewrite <- Equal; auto with zarith.

 rewrite shift_associative.
 rewrite shift_associative.

 apply Increasing; auto with zarith.
Qed.

Goal typed_external_lemma_Increasing_Shift.
Hint Increasing_Shift,property.
Proof.
  intros m n L a.
  intros mLower mUpper L32 Increasing.
  unfold P_Increasing_2_.
  unfold P_Increasing_1_ in *.
  intros.
  rewrite shift_associative.
  rewrite shift_associative.
  apply Increasing; auto with zarith.
Qed.

Goal typed_external_lemma_InnerProduct_Unchanged.
Hint InnerProduct_Unchanged,property.
Proof.
  Require Import Psatz.
  intros init n L K a b.
  intros LChunk KChunk V.
  assert (X: (n <= 0 \/ n > 0)%Z) by lia.
  destruct X as [lez|gtz].
  {
    intros.
    assert (L_InnerProduct L a b n init = init).
    {
      now apply FixL_InnerProduct.
    }
    assert (L_InnerProduct K a b n init = init).
    {
      now apply FixL_InnerProduct.
    }
    now rewrite H2.
  }
  apply natlike_rec3 with (z := n); auto with zarith.
  {
    intros.
    assert (L_InnerProduct L a b 0 init = init).
    {
      now apply FixL_InnerProduct.
    }
    assert (L_InnerProduct K a b 0 init = init).
    {
      now apply FixL_InnerProduct.
    }
    now rewrite H2.
  }

  intro.
  replace (Z.pred z) with (z - 1)%Z in * by lia.
  intros.

  assert (IHL: ((L_InnerProduct L a b (z-1) init) + 
                (L.[shift_sint32 b (z-1)]) * (L.[shift_sint32 a (z-1)]) 
               = L_InnerProduct L a b z init)%Z ).  
  {
    apply (@FixL_InnerProduct z init L a b); lia.
  }
  rewrite <- IHL.

  assert (IHK: ((L_InnerProduct K a b (z-1) init) + 
                (K.[shift_sint32 b (z-1)]) * (K.[shift_sint32 a (z-1)]) 
               = L_InnerProduct K a b z init)%Z ). 
  {
    apply (@FixL_InnerProduct z init K a b); lia.
  }
  rewrite <- IHK.

  assert (KLa: K.[ shift_sint32 b (z - 1)] = L.[ shift_sint32 b (z - 1)]) by (apply H2; lia).
  rewrite KLa.
  assert (KLb: K.[ shift_sint32 a (z - 1)] = L.[ shift_sint32 a (z - 1)]) by (apply H1; lia).
  rewrite KLb.
  enough (L_InnerProduct L a b (z-1) init = L_InnerProduct K a b (z-1) init) by lia.
  apply H0.
  - apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=0%Z) (i_2:=z); auto with zarith.
  - apply A_UnchangedLemmas.Q_Unchanged_Shrink with (i_3:=0%Z) (i_2:=z); auto with zarith. 
Qed.

Goal typed_external_lemma_Less_Antisymmetry.
Hint Less_Antisymmetry,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_lemma_Less_Transitivity.
Hint Less_Transitivity,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_lemma_LowerBound_Shift.
Hint LowerBound_Shift,property.
Proof.
  Require Import Psatz.
  unfold P_LowerBound_1_.
  intros v b c d L a LChunk V LowerBound i X Y.

  replace i with (b + (i - b))%Z by lia.
  rewrite <- shift_associative.
  apply LowerBound; lia.

Qed.

Goal typed_external_lemma_MultisetAdd_Distinct.
Hint MultisetAdd_Distinct,property.
Proof.
  Require Import Psatz.
  intros v i n L K a.
  intros Lai Kai.
  unfold L_At in *.
  intros iNN iLess LChunk KChunk VChunk.
  intros Reorder1 Reorder2.
  unfold P_MultisetAdd.
  symmetry.
  rewrite <- A_Count.Q_Count_Cut with (i_1:=i); auto with zarith.
  rewrite <- Reorder1; auto with zarith.
  rewrite <- Reorder2; auto with zarith.
  assert(X: (1 + i - 1 = i)%Z) by lia.
  replace (L_Count_1_ L a i (1 + i) v)%Z with 1%Z.
  - enough (L_Count_1_ K a 0 n v = L_Count_1_ K a (1 + i) n v + L_Count_1_ K a 0 i v)%Z by lia.
    rewrite <- A_Count.Q_Count_Cut with (i_1:=i); auto with zarith.
    replace (L_Count_1_ K a i (1 + i) v)%Z with 0%Z; auto with zarith.
    rewrite <- A_Count.Q_Count_Miss; auto with zarith.
    + rewrite A_Count.Q_Count_Empty; auto with zarith.
    + now rewrite X.
  - rewrite <- A_Count.Q_Count_Hit; auto with zarith.
    + rewrite A_Count.Q_Count_Empty; auto with zarith.
    + now rewrite X.
Qed.

Goal typed_external_lemma_MultisetMinus_Distinct.
Hint MultisetMinus_Distinct,property.
Proof.
  intros v i n L K a ai x x_1.
  subst ai x x_1.
  intros Lai Kai iLower nLower L32 K32 v32 Lai32 Kai32.
  intros Reorder1 Reorder2.
  unfold P_MultisetMinus.

  apply Q_MultisetAdd_Distinct with (i_1:=i); auto with zarith.
  - apply A_MultisetReorder.Q_MultisetReorder_Symmetric; auto with zarith.
  - apply A_MultisetReorder.Q_MultisetReorder_Symmetric; auto with zarith.
Qed.

Goal typed_external_lemma_MultisetReorder_DisjointUnion.
Hint MultisetReorder_DisjointUnion,property.
Proof.
  intros i k n K L a.
  intros iNN kLower kUpper KChunk LChunk.
  intros Reorder1 Reorder2.
  unfold P_MultisetReorder_1_.
  intros v V.

  rewrite <- A_Count.Q_Count_Union with (i_1:=k); auto with zarith.
  rewrite Reorder2; auto with zarith.
  rewrite Reorder1; auto with zarith.
  rewrite A_Count.Q_Count_Union; auto with zarith.
Qed.

Goal typed_external_lemma_MultisetReorder_LowerBound.
Hint MultisetReorder_LowerBound,property.
Proof.
  intros n v L K a nNN LChunk KChunk. 
  intros V Reorder K_Lower.
  assert(n_cases: (0 < n \/ 0 = n \/ 0 > n)%Z) by apply Ztrichotomy.
  destruct n_cases as [pos | non_pos].
  - unfold P_LowerBound_2_.
    unfold P_LowerBound_1_.
    intros.
    assert (X: P_SomeEqual_2_ K a n (L .[ shift_sint32 a i])).
    + apply Q_MultisetReorder_SomeEqual; auto with zarith.
    + unfold P_SomeEqual_2_ in X.
      unfold P_SomeEqual_1_ in X.
      destruct X as [k [A B]].
      rewrite <- A.
      now apply K_Lower.
  - unfold P_LowerBound_2_.
    unfold P_LowerBound_1_.
    auto with zarith.
Qed.

Goal typed_external_lemma_MultisetReorder_PartitionLowerBound.
Hint MultisetReorder_PartitionLowerBound,property.
Proof.
  intros m n L K a.
  intros x mLower mUpper LChunk KChunk.
  subst x.
  intros Partition AZero Unchanged Reorder.
  enough (X: P_SomeEqual_1_ K a 0 m (L .[ shift_sint32 a 0])).
  + unfold P_SomeEqual_1_ in X.
    destruct X as [k [A B]].
    rewrite <- A.
    unfold P_LowerBound_1_.
    intros i iLower iUpper.
    rewrite <- Unchanged; auto with zarith.
  + apply Q_MultisetReorder_SomeEqual; auto with zarith.
Qed.

Goal typed_external_lemma_MultisetReorder_SomeEqual.
Hint MultisetReorder_SomeEqual,property.
Proof.
  Require Import Psatz.
  intros n i L K a x.
  subst x.
  intros nPos Lower Upper LChunk KChunk Reorder LAi.

  unfold P_SomeEqual_2_.
  unfold P_MultisetReorder_2_ in Reorder.
  unfold P_MultisetReorder_1_ in Reorder.


  (* work around for https://bts.frama-c.com/view.php?id=2332 *)
  (* assert(CType: Cint.is_sint32 (L .[ shift_sint32 a i])) by admit. *)

  apply A_CountFind.Q_Count_SomeEqual; auto with zarith.
  rewrite Reorder; auto with zarith.
  rewrite <- A_Count.Q_Count_Union with (i_1:=i); auto with zarith.
  assert(X: (0 <= A_Count.L_Count_1_ L a 0 i (L .[ shift_sint32 a i]))%Z) by 
    (apply A_Count.Q_Count_Bounds; auto with zarith).

  enough(0 < A_Count.L_Count_1_ L a i n (L .[ shift_sint32 a i]))%Z by auto with zarith.
  rewrite <- A_Count.Q_Count_Union with (i_1:=(1+i)%Z); auto with zarith.

  assert(Y:(0 <= A_Count.L_Count_1_ L a (1 + i) n (L .[ shift_sint32 a i]))%Z) by 
    (apply A_Count.Q_Count_Bounds; auto with zarith).

  enough (0 < A_Count.L_Count_1_ L a i (1 + i) (L .[ shift_sint32 a i]))%Z by lia.
  rewrite <- A_Count.Q_Count_Hit; auto with zarith.
  - rewrite A_Count.Q_Count_Empty; auto with zarith.
  - now replace (1+i-1)%Z with i by lia.
Qed.

Goal typed_external_lemma_MultisetReorder_UpperBound.
Hint MultisetReorder_UpperBound,property.
Proof.
  Require Import Psatz.
  intros n v L K a.
  intros nNN LChunk KChunk V Reorder K_Upper.
  assert(n_cases: (0 < n \/ 0 = n \/ 0 > n)%Z) by apply Ztrichotomy.
  destruct n_cases as [pos | non_pos].
  - unfold P_UpperBound_2_.
    unfold P_UpperBound_1_.
    intros.
    assert (X: P_SomeEqual_2_ K a n (L .[ shift_sint32 a i])).
    + apply Q_MultisetReorder_SomeEqual; auto with zarith.
    + unfold P_SomeEqual_2_ in X.
      unfold P_SomeEqual_1_ in X.
      destruct X as [k [A B]].
      rewrite <- A.
      now apply K_Upper.
  - unfold P_UpperBound_2_.
    unfold P_UpperBound_1_.
    auto with zarith.
Qed.

Goal typed_external_lemma_MultisetRetain_Distinct.
Hint MultisetRetain_Distinct,property.
Proof.
  Require Import Psatz.
  intros v m n L K a Lam Kam.
  unfold L_At in *.
  intros mNN mn.
  intros L32 K32 v32.
  intros Reorder1 Reorder2.
  unfold P_MultisetRetain.
  rewrite <- A_Count.Q_Count_Cut with (i_1:=m); auto with zarith.
  rewrite Reorder1; trivial.
  rewrite Reorder2; trivial.
  symmetry.
  rewrite <- A_Count.Q_Count_Cut with (i_1:=m); auto with zarith.
  enough (L_Count_1_ L a m (1 + m) v = L_Count_1_ K a m (1 + m) v)%Z by lia.
  assert(X: (1+m-1 <= m)%Z) by lia.
  assert(Y: (1+m-1 = m)%Z) by lia.
  rewrite <- A_Count.Q_Count_Miss; auto with zarith.
  - rewrite A_Count.Q_Count_Empty; auto.
    rewrite <- A_Count.Q_Count_Miss; auto with zarith.
    + rewrite A_Count.Q_Count_Empty; auto.
    + now rewrite Y.
  - now rewrite Y.
Qed.

Goal typed_external_lemma_MultisetSwap_Middle.
Hint MultisetSwap_Middle,property.
Proof.
  Require Import Psatz.
  intros i k n K L a.
  intros KChunk LChunk Swapped.
  unfold P_MultisetReorder_1_.
  intros v V.
  unfold P_ArraySwap in Swapped.
  destruct Swapped as [A [B [C [D [E [F [G H]]]]]]].
  unfold A_At.L_At in *.

  rewrite <- A_Count.Q_Count_Union with (i_1:=k); auto with zarith.
  rewrite Z.add_comm.
  rewrite <- A_Count.Q_Count_Union with (i_1:=1+i); auto with zarith.
  rewrite A_MultisetReorder.Q_Unchanged_MultisetReorder with (t_1:=K); auto with zarith.
  symmetry.
  rewrite <- A_Count.Q_Count_Union with (i_1:=k); auto with zarith.
  rewrite Z.add_comm.
  rewrite <- A_Count.Q_Count_Union with (i_1:=1+i); auto with zarith.

  enough(A_Count.L_Count_1_ K a i (1 + i) v + A_Count.L_Count_1_ K a k (1 + k) v =
         A_Count.L_Count_1_ L a i (1 + i) v + A_Count.L_Count_1_ L a k (1 + k) v) by lia.

  rewrite Z.add_comm.
  rewrite A_Count.Q_Count_Single with (i_1:=i) (t:=L) (a_1:=a); auto with zarith.
  enough(A_Count.L_Count_1_ K a i (1 + i) v = A_Count.L_Count_1_ L a k (1 + k) v) by lia.
  rewrite A_Count.Q_Count_Single with (i_1:=k) (t:=L) (a_1:=a); auto with zarith.
Qed.

Goal typed_external_lemma_MultisetSwap_MultisetReorder.
Hint MultisetSwap_MultisetReorder,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_lemma_Multiset_RetainDistinct.
Hint Multiset_RetainDistinct,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_lemma_PartialSum_Step.
Hint PartialSum_Step,property.
Proof.
  Require Import Psatz.
  intros n L a b x.
  subst x.
  intros Accumulate nNN LChunk PartialSum bChunk.
  unfold P_PartialSum.
  intros.
  assert(less_equal: (i < n \/ i = n)%Z) by lia.
  destruct less_equal as [less|equal].
  - apply PartialSum; auto with zarith.
  - 
Qed.

Goal typed_external_lemma_PartialSum_Unchanged.
Hint PartialSum_Unchanged,property.
Proof.
  Require Import Psatz.
  intros n L K a b.
  intros nNN LChunk KChunk aUnchanged bUnchanged Sum.
  unfold P_PartialSum.
  intros i iNN iLess.
  rewrite <- bUnchanged; auto with zarith.
  rewrite <- A_AccumulateDefault.Q_AccumulateDefault_Unchanged with (t_1:=K); auto with zarith.
  unfold P_Unchanged_2_.
  unfold P_Unchanged_1_.
  intros.
  rewrite aUnchanged; auto with zarith.
Qed.

Goal typed_external_lemma_RemoveCopy_Skip.
Hint RemoveCopy_Skip,property.
Proof.
  Require Import Psatz.
  intros v m n L K a b.
  intros Equal mNN Less V Ua Ub Ka.
  unfold P_RemoveCopy in *.
  intros.
  unfold L_CountNotEqual_2_ in *.
  assert(A: (L_CountNotEqual_1_ L a 0 (1 + m) v = L_CountNotEqual_1_ L a 0 m v)%Z)
            by (rewrite A_CountNotEqual.Q_CountNotEqual_Miss; auto with zarith).
  rewrite A in H0.
  assert(B: (i < L_CountNotEqual_1_ K a 0 m v)%Z).
  {
    rewrite <- A_CountNotEqual.Q_CountNotEqual_Unchanged with (t_1:=L); auto with zarith.
    apply A_Unchanged.Q_Unchanged_Shrink with (i:=n); auto with zarith.
  }

  (* get rid of (1+m) *)
  assert (mPos: (0 < m)%Z).  {
    assert((0 = m \/ 0 < m)%Z) by lia.
    destruct H1.
    rewrite <- H1 in H0.
    rewrite A_CountNotEqual.Q_CountNotEqual_Empty in H0; auto with zarith.
    trivial.
  }
  rewrite A_RemovePartition.Q_RemovePartition_Extend; auto with zarith.
  rewrite A_RemovePartition.Q_RemovePartition_Unchanged with (t:=K); auto with zarith.
  {
    replace(L .[ shift_sint32 b i]) with (K .[ shift_sint32 b i]).
    {
      replace (L .[ shift_sint32 a (L_RemovePartition K a m v i)]) with
              (K .[ shift_sint32 a (L_RemovePartition K a m v i)]).
      - rewrite Ka; auto with zarith.
      - symmetry.
        rewrite Ua; auto with zarith.
        + apply A_RemovePartition.Q_RemovePartition_Lower; auto with zarith.
        + enough(L_RemovePartition K a m v i < m)%Z by lia.
          apply A_RemovePartition.Q_RemovePartition_Upper; auto with zarith.
    }
    {
      rewrite Ub; auto with zarith.
      enough (0 + L_CountNotEqual_1_ L a 0 m v <= m)%Z by lia.
      apply A_CountNotEqual.Q_CountNotEqual_Upper; auto with zarith.
    }
  }
  {
    unfold P_Unchanged_2_.
    apply A_Unchanged.Q_Unchanged_Shrink with (i:=n); auto with zarith.
  }
Qed.

Goal typed_external_lemma_RemoveImpliesNotHasValue.
Hint RemoveImpliesNotHasValue,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_lemma_RemovePartition_Core.
Hint RemovePartition_Core,property.
Proof.
  Require Import Psatz.
  intros v n p L a x x_1.
  subst x x_1.
  intros nPos pNN Less LChunk V W.
  unfold L_CountNotEqual_2_ in *.

  revert Less.

  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    intros.
    rewrite <- Q_RemovePartition_Next; auto with zarith.
    rewrite Q_RemovePartition_Left; auto with zarith.
    replace (1 + -1)%Z with 0%Z by lia.

    split.
    {
      apply A_FindNotEqual.Q_FindNotEqual_ResultNotEqual; auto with zarith.
      - now apply A_FindNotEqual.Q_FindNotEqual_Lower.
      - apply A_CountFindNotEqual.Q_CountNotEqual_FindNotEqual; auto with zarith.
    }
    {
      split.
      {
        assert(X: (0 + L_CountNotEqual_1_ L a 0 (0 + L_FindNotEqual_1_ L a 0 n v) v = 0)%Z).
        + rewrite A_CountFindNotEqual.Q_CountNotEqual_Zero; auto with zarith.
        + symmetry.
          rewrite <- A_CountNotEqual.Q_CountNotEqual_Union
            with (i_1:=(0 + L_FindNotEqual_1_ L a 0 n v)%Z); auto with zarith.
          * apply A_FindNotEqual.Q_FindNotEqual_Lower; auto with zarith.
          * apply A_FindNotEqual.Q_FindNotEqual_Upper; auto with zarith.
      }
      {
        apply A_CountFindNotEqual.Q_CountNotEqual_FindNotEqual; auto with zarith.
      }
    }
  }
  {
    intros z zNN IHz.
    intros.
    replace (Z.succ z) with (1+z)%Z in * by lia.
    assert(X: (z < L_CountNotEqual_1_ L a 0 n v)%Z) by lia.
    apply IHz in X; auto with zarith.
    destruct X as [A1 [A2 A3]].
    assert(B: (0 <= L_RemovePartition L a n v z)%Z).
    {
      apply Q_RemovePartition_Lower; auto with zarith.
      unfold L_CountNotEqual_2_; lia.
    }

    assert(C: (1 < L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) n v)%Z) by lia.
    assert(D: (0 < L_CountNotEqual_1_ L a (1 + L_RemovePartition L a n v z) n v)%Z).
    {
      assert(Y: (L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) n v =
                  L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) (1+ L_RemovePartition L a n v z) v +
                  L_CountNotEqual_1_ L a (1+ L_RemovePartition L a n v z) n v)%Z).
      {
        rewrite <- A_CountNotEqual.Q_CountNotEqual_Union with 
          (i_1 := (1+ L_RemovePartition L a n v z)%Z); auto with zarith.
      }
      enough(0 <= L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) (1 + L_RemovePartition L a n v z) v <= 1)%Z by lia.
      split.
      - apply A_CountNotEqual.Q_CountNotEqual_Lower; auto with zarith.
      - enough (L_RemovePartition L a n v z + 
                L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) (1 + L_RemovePartition L a n v z) v <= 
                1 + L_RemovePartition L a n v z)%Z by lia.
        apply A_CountNotEqual.Q_CountNotEqual_Upper; auto with zarith.
    }

    split.
    {
      rewrite <- Q_RemovePartition_Next; auto with zarith.
      replace (1+z-1)%Z with z by lia.
      apply A_FindNotEqual.Q_FindNotEqual_ResultNotEqual; auto with zarith.
      - now apply A_FindNotEqual.Q_FindNotEqual_Lower.
      - apply A_CountFindNotEqual.Q_CountNotEqual_FindNotEqual; auto with zarith.
        assert(E: (L_RemovePartition L a n v z + L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) n v <= n)%Z).
        + apply A_CountNotEqual.Q_CountNotEqual_Upper; auto with zarith.
        + lia.
    }
    {
      split.
      {
        remember (L_RemovePartition L a n v z) as x.
        symmetry.
        rewrite <- Q_RemovePartition_Next; auto with zarith.
        replace (1+z-1)%Z with z by lia.
        rewrite <- Heqx.
        symmetry in A2.

        remember (L_FindNotEqual_1_ L a (1 + x) n v) as y.

        assert(P: (L_CountNotEqual_1_ L a 0 n v = 
                  L_CountNotEqual_1_ L a 0 (1+x) v + 
                  L_CountNotEqual_1_ L a (1 + x + L_FindNotEqual_1_ L a (1 + x) n v) n v)%Z).
        {
          rewrite <- A_CountFindNotEqual.Q_CountNotEqual_Decrement with (i_1 := (1+x)%Z); auto with zarith.
          rewrite Heqx.
          assert(E: (L_RemovePartition L a n v z + L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) n v <= n)%Z).
          * apply A_CountNotEqual.Q_CountNotEqual_Upper; auto with zarith.
          * subst x; lia.
        }

        rewrite <- Heqy in P.
        enough(L_CountNotEqual_1_ L a 0 (1 + x) v = 1 + z)%Z by lia.
        assert(Q: (L_CountNotEqual_1_ L a 0 n v = 
                   L_CountNotEqual_1_ L a 0 x v + L_CountNotEqual_1_ L a x n v)%Z) by
         (rewrite <- A_CountNotEqual.Q_CountNotEqual_Union with (i_1:=x); auto with zarith).

        assert(R: (L_CountNotEqual_1_ L a 0 x v = z)%Z) by lia.
        rewrite <- R.
        symmetry.
        assert(S: (L_CountNotEqual_1_ L a 0 (1 + x) v = 
                  L_CountNotEqual_1_ L a 0 x v + L_CountNotEqual_1_ L a x (1+x) v)%Z) by 
         (rewrite <- A_CountNotEqual.Q_CountNotEqual_Union with (i_1:=x); auto with zarith).
        enough (L_CountNotEqual_1_ L a x (1+x) v = 1)%Z by lia.
        rewrite <- A_CountNotEqual.Q_CountNotEqual_Hit; auto with zarith.
        rewrite A_CountNotEqual.Q_CountNotEqual_Empty; auto with zarith.
      }
      {
        rewrite <- Q_RemovePartition_Next; auto with zarith.
        replace (1+z-1)%Z with z by lia.
        apply A_CountFindNotEqual.Q_CountNotEqual_FindNotEqual; auto with zarith.
        assert(E: (L_RemovePartition L a n v z + L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) n v <= n)%Z).
        - apply A_CountNotEqual.Q_CountNotEqual_Upper; auto with zarith.
        - lia.
      }
    }
  }
Qed.

Goal typed_external_lemma_RemovePartition_Count.
Hint RemovePartition_Count,property.
Proof.
  intros.
  apply Q_RemovePartition_Core; auto with zarith.
Qed.

Goal typed_external_lemma_RemovePartition_Extend.
Hint RemovePartition_Extend,property.
Proof.
  Require Import Psatz.
  intros v n p L a.
  intros nPos pNN Less LChunk V.
  revert Less.
  apply natlike_rec2 with (z:=p); auto with zarith.
  {
    intros.
    rewrite <- Q_RemovePartition_Next; auto with zarith.
    - rewrite Q_RemovePartition_Left; auto with zarith.
      replace (1 + -1)%Z with 0%Z by lia.
      rewrite <- Q_RemovePartition_Next; auto with zarith.
      rewrite Q_RemovePartition_Left; auto with zarith.
      replace (1 + -1)%Z with 0%Z by lia.
      assert(X: (0 + L_FindNotEqual_1_ L a 0 n v < n)%Z).
      * apply A_CountFindNotEqual.Q_CountNotEqual_FindNotEqual; auto with zarith.
      * rewrite A_FindNotEqual.Q_FindNotEqual_Hit; auto with zarith.
    - enough (L_CountNotEqual_2_ L a n v <= L_CountNotEqual_2_ L a (1 + n) v)%Z; auto with zarith.
      apply A_CountNotEqual.Q_CountNotEqual_WeaklyIncreasing; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (Z.succ z) with (1+z)%Z by lia.
    intros.
    rewrite <- Q_RemovePartition_Next; auto with zarith.
    {
      replace (1 + z - 1)%Z with z by lia.
      symmetry.
      rewrite <- Q_RemovePartition_Next; auto with zarith.
      replace (1 + z - 1)%Z with z by lia.
      rewrite IHz; auto with zarith.
      remember (1 + L_RemovePartition L a n v z)%Z as x.
      assert(X: (x + L_FindNotEqual_1_ L a x n v < n)%Z).
      - rewrite Heqx.
        apply A_CountFindNotEqual.Q_CountNotEqual_FindNotEqual; auto with zarith.
        + enough (0 <= L_RemovePartition L a n v z)%Z by lia.
            apply Q_RemovePartition_Lower; auto with zarith.
        + assert(Y: (L_RemovePartition L a n v z < L_RemovePartition L a n v (1+z))%Z).
            * replace z with ((1+z)-1)%Z by lia.
                replace (1 + (1 + z - 1))%Z with (1+z)%Z by lia.
                apply Q_RemovePartition_StrictlyWeakIncreasing; auto with zarith.
            * enough(L_RemovePartition L a n v (1 + z) < n)%Z by lia.
                apply Q_RemovePartition_Upper; auto with zarith.
        + assert(A: (z + L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) n v = 
                        L_CountNotEqual_1_ L a 0 n v)%Z) 
                        by (rewrite Q_RemovePartition_Count; auto with zarith).
            unfold L_CountNotEqual_2_ in *.
            assert(B: (1 < L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) n v)%Z) by lia.
            assert(C: (1 = L_CountNotEqual_1_ L a (L_RemovePartition L a n v z) 
                                                      (1 + L_RemovePartition L a n v z) v)%Z).
            * rewrite <- A_CountNotEqual.Q_CountNotEqual_Hit; auto with zarith.
                rewrite A_CountNotEqual.Q_CountNotEqual_Empty; auto with zarith.
                apply Q_RemovePartition_NotEqual; auto with zarith.
                unfold L_CountNotEqual_2_; lia.
            * rewrite <- A_CountNotEqual.Q_CountNotEqual_Union 
                  with (i_1:=(1 + L_RemovePartition L a n v z)%Z) in B; auto with zarith.
            **  apply Q_RemovePartition_Lower; auto with zarith.
                  unfold L_CountNotEqual_2_; lia.
            **  enough(L_RemovePartition L a n v z < n)%Z by lia.
                  apply Q_RemovePartition_Upper; auto with zarith.
                  unfold L_CountNotEqual_2_; lia.
      - rewrite A_FindNotEqual.Q_FindNotEqual_Hit; auto with zarith.
        enough (0 <= L_FindNotEqual_1_ L a x n v)%Z by lia.
        apply A_FindNotEqual.Q_FindNotEqual_Lower; auto with zarith.
    }
    {
      enough(L_CountNotEqual_2_ L a n v <= L_CountNotEqual_2_ L a (1 + n) v)%Z by lia.
      apply A_CountNotEqual.Q_CountNotEqual_WeaklyIncreasing; auto with zarith.
    }
  }
Qed.

Goal typed_external_lemma_RemovePartition_Lower.
Hint RemovePartition_Lower,property.
Proof.
  Require Import Psatz.
  intros v n p L a.
  intros nPos pNN pLT LChunk V.
  revert pLT.

  apply natlike_rec3 with (z:=p); auto with zarith.
  {
    intros.
    rewrite <- Q_RemovePartition_Next; auto with zarith.
    replace (0-1)%Z with (-1)%Z by lia.
    rewrite Q_RemovePartition_Left; auto with zarith.
    cbn.
    apply A_FindNotEqual.Q_FindNotEqual_Lower; auto with zarith.
  }
  {
    intros z zNN IHz.
    replace (Z.pred z) with (z-1)%Z in * by lia.
    intros.
    rewrite <- Q_RemovePartition_Next; auto with zarith.
    enough(0 <= L_FindNotEqual_1_ L a (1 + L_RemovePartition L a n v (z - 1)) n v)%Z by lia.
    apply A_FindNotEqual.Q_FindNotEqual_Lower; auto with zarith.
  }
Qed.

Goal typed_external_lemma_RemovePartition_Next.
Hint RemovePartition_Next,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_lemma_RemovePartition_NextRight.
Hint RemovePartition_NextRight,property.
Proof.
  intros v n L a p x.
  intros nNN LChunk V.
  rewrite Q_RemovePartition_Right; auto with zarith.
  rewrite A_FindNotEqual.Q_FindNotEqual_AllEqual; auto with zarith.
  - enough (L_RemovePartition L a n v (p - 1) < n)%Z; auto with zarith.
    apply Q_RemovePartition_Upper; auto with zarith.
    admit.
  -
Qed.

Goal typed_external_lemma_RemovePartition_Segment.
Hint RemovePartition_Segment,property.
Proof.
  Require Import Psatz.
  intros v n p L a.
  intros nPos pNN pLE LChunk V.
  remember (1 + L_RemovePartition L a n v p)%Z as x.
  assert(less_equal: (1+p < L_CountNotEqual_2_ L a n v \/ 1+p = L_CountNotEqual_2_ L a n v)%Z) by lia.
  destruct less_equal as [less|equal].
  - replace (L_RemovePartition L a n v (1 + p)) with (x + (L_FindNotEqual_1_ L a x n v))%Z.
    + apply A_FindNotEqual.Q_FindNotEqual_ResultAllEqual; auto with zarith.
      rewrite Heqx.
      enough (L_RemovePartition L a n v p < n)%Z by auto with zarith.
      apply Q_RemovePartition_Upper; auto with zarith.
    + rewrite <- Q_RemovePartition_Next; auto with zarith.
      replace (1+p-1)%Z with p by auto with zarith.
      rewrite Heqx; auto with zarith.
  - rewrite Q_RemovePartition_Right; auto with zarith.
    rewrite Heqx.
    admit.
Qed.

Goal typed_external_lemma_RemovePartition_StrictlyIncreasing.
Hint RemovePartition_StrictlyIncreasing,property.
Proof.
  intros v n p q L a.
  intros nPos pNN pLess qLess LChunk V.
  remember (-p + q)%Z as k.
  replace q with (p+k)%Z in * by auto with zarith.
  assert(kPos: (0 < k)%Z) by auto with zarith.
  assert(kPos2 := kPos).
  revert pLess qLess.

  apply natlike_rec2 with (z := k); auto with zarith.
  intros z zNN IHz.
  replace (Z.succ z) with (1+z)%Z by auto with zarith.
  intros.
  replace (p + (1 + z))%Z with (1+(p+z))%Z in * by auto with zarith.
  assert(X: (L_RemovePartition L a n v p < L_RemovePartition L a n v (p + z))%Z).
  - apply IHz; auto with zarith.
  enough(L_RemovePartition L a n v (p + z) < L_RemovePartition L a n v (p + (1 + z)))%Z by auto with zarith.
  admit.

Qed.

Goal typed_external_lemma_RemovePartition_Unchanged.
Hint RemovePartition_Unchanged,property.
Proof.
  Require Import Psatz.
  intros v n p K L a KChunk LChunk V U.

  assert(A: (p < 0 \/ 0 <= p)%Z) by lia.
  destruct A.
  {
    rewrite Q_RemovePartition_Left; auto with zarith.
    rewrite Q_RemovePartition_Left; auto with zarith.
  }
  {
    assert(B: (n <= 0 \/ 0 < n)%Z) by lia.
    destruct B.
    rewrite Q_RemovePartition_Empty; auto with zarith.
    rewrite Q_RemovePartition_Empty; auto with zarith.

    assert(C: (p < L_CountNotEqual_1_ L a 0 n v  \/ L_CountNotEqual_1_ L a 0 n v <= p)%Z) by lia.
    destruct C.
    {
      assert ((p < L_CountNotEqual_1_ K a 0 n v)%Z).
      rewrite A_CountNotEqual.Q_CountNotEqual_Unchanged with (t:=L); auto with zarith.
      revert H1.
      apply natlike_rec2 with (z:=p); auto with zarith.
      {
        intros.
        rewrite <- Q_RemovePartition_Next; auto with zarith.
        - rewrite Q_RemovePartition_Left; auto with zarith.
          rewrite <- Q_RemovePartition_Next; auto with zarith.
          rewrite Q_RemovePartition_Left; auto with zarith.
          replace (1 + -1)%Z with 0%Z by lia.
          rewrite A_FindNotEqual.Q_FindNotEqual_Unchanged with (t:=L); auto with zarith.
        - unfold L_CountNotEqual_2_; lia.
      }
      {
        intros z zNN IHz.
        intros.
        replace (Z.succ z) with (1+z)%Z in * by lia.
        assert((1 + z < L_CountNotEqual_1_ K a 0 n v)%Z) by 
          (rewrite A_CountNotEqual.Q_CountNotEqual_Unchanged with (t:=L); auto with zarith).

        rewrite <- Q_RemovePartition_Next; auto with zarith.
        symmetry.
        rewrite <- Q_RemovePartition_Next; auto with zarith.
        replace (1 + z - 1)%Z with z by lia.
        rewrite IHz; auto with zarith.
        replace (1 + z - 1)%Z with z by lia.
        enough( L_FindNotEqual_1_ L a (1 + L_RemovePartition L a n v z) n v =
                L_FindNotEqual_1_ K a (1 + L_RemovePartition L a n v z) n v)%Z by lia.
        rewrite <- A_FindNotEqual.Q_FindNotEqual_Unchanged with (t_1:=K); auto with zarith.
        unfold P_Unchanged_1_.
        intros.
        rewrite U; auto with zarith.
        enough(0 <= L_RemovePartition L a n v z)%Z by lia.
        apply Q_RemovePartition_Lower; auto with zarith.
        unfold L_CountNotEqual_2_; lia.
      }
    }
    {
      rewrite Q_RemovePartition_Right; auto with zarith.
      - rewrite Q_RemovePartition_Right; auto with zarith.
      - unfold L_CountNotEqual_2_.
        rewrite A_CountNotEqual.Q_CountNotEqual_Unchanged with (t:=L); auto with zarith.
    }
  }
Qed.

Goal typed_external_lemma_Remove_Skip.
Hint Remove_Skip,property.
Proof.
  Require Import Psatz.
  intros v m n L K a  am LV LK.
  intros mNN mLess V Rm.
  subst am.
  unfold P_Remove in *.
  intros i iNN iLess.
  unfold L_CountNotEqual_2_ in *.
  rewrite A_CountNotEqual.Q_CountNotEqual_Miss in iLess; auto with zarith.
  rewrite A_RemovePartition.Q_RemovePartition_Extend; auto with zarith.
  - assert ((m = 0 \/ 0 < m)%Z) by lia.
    destruct H; auto with zarith.
    rewrite A_CountNotEqual.Q_CountNotEqual_Empty in iLess; auto with zarith.
  - unfold L_CountNotEqual_2_. admit.
Qed.

Goal typed_external_lemma_Remove_Update.
Hint Remove_Update,property.
Proof.
  Require Import Psatz.
  intros v m L K a x.
  subst x.
  intros A B mNN V C.

  unfold P_Remove in *.
  unfold L_CountNotEqual_2_ in *.
  intros i iNN iLess.
  assert(D: (L_CountNotEqual_1_ K a 0 (1 + m) v = 1 + L_CountNotEqual_1_ K a 0 m v)%Z).
  rewrite A_CountNotEqual.Q_CountNotEqual_Hit; auto with zarith.
  rewrite D in iLess.
  assert(less_equal: (i < L_CountNotEqual_1_ K a 0 m v  \/  i = L_CountNotEqual_1_ K a 0 m v)%Z) by lia.
  destruct less_equal as [less|equal].
  {
    rewrite <- C; auto with zarith.
    rewrite A_RemovePartition.Q_RemovePartition_Extend; auto with zarith.
    (* show that m cannot be qual to 0 *)
    assert((m = 0 \/ 0 < m)%Z) by lia.
    destruct H; auto with zarith.
    rewrite A_CountNotEqual.Q_CountNotEqual_Empty in less; auto with zarith.
  }
  {
    replace (L_CountNotEqual_1_ K a 0 (1 + m) v - 1)%Z with (L_CountNotEqual_1_ K a 0 m v)%Z in B by lia.
    rewrite equal.
    rewrite B.
    auto with zarith.
    admit.
  }
Qed.

Goal typed_external_lemma_SomeEqual_Count.
Hint SomeEqual_Count,property.
Proof.
  Require Import Psatz.
  intros v m n L a.
  intros mNN Less V Some.
  unfold P_SomeEqual_1_ in *.
  destruct Some as [k [A B]].

  assert(C: (1 = L_Count_1_ L a k (1+k) v)%Z).
  {
    rewrite <- A_Count.Q_Count_Hit; auto with zarith.
    - rewrite A_Count.Q_Count_Empty; auto with zarith.
    - now replace (1+k-1)%Z with k by lia.
  }

  rewrite <- A_Count.Q_Count_Union with (i_1:=(1+k)%Z); auto with zarith.
  rewrite <- A_Count.Q_Count_One; auto with zarith.
  enough(0 <= L_Count_1_ L a (1 + k) n v /\ 0 <= L_Count_1_ L a m k v)%Z by lia.
  split; (apply A_Count.Q_Count_Bounds; auto with zarith).
Qed.

Goal typed_external_lemma_StrictLowerBound_Shift.
Hint StrictLowerBound_Shift,property.
Proof.
  Require Import Psatz.
  unfold P_StrictLowerBound_1_ in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_2 + (i0 - i_2))%Z by lia.

  rewrite <- shift_associative.
  apply H1; lia.

Qed.

Goal typed_external_lemma_StrictUpperBound_Shift.
Hint StrictUpperBound_Shift,property.
Proof.
  Require Import Psatz.
  unfold P_StrictUpperBound_1_ in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_1 + (i0 - i_1))%Z by lia.

  rewrite <- shift_associative.
  apply H1; lia.

Qed.

Goal typed_external_lemma_Unchanged_Shift.
Hint Unchanged_Shift,property.
Proof.
  intros p q r K L a KChunk LChunk H.
  unfold shift_sint32 in *.
  unfold P_Unchanged_1_ in *.
  unfold shift_sint32 in *.
  intros i iLower iUpper.

  remember (i - p)%Z as k.
  replace i with (p + k)%Z by auto with zarith.
  rewrite <- shift_associative.
  apply H; auto with zarith.
Qed.

Goal typed_external_lemma_UpperBound_Shift.
Hint UpperBound_Shift,property.
Proof.
  Require Import Psatz.
  unfold P_UpperBound_1_ in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_1 + (i0 - i_1))%Z by lia.

  rewrite <- shift_associative.
  apply H1; lia.

Qed.

Goal typed_external_lemma_WeaklyIncreasing_Increasing.
Hint WeaklyIncreasing_Increasing,property.
Proof.
  Require Import Psatz.
  intros m n L a Lower Upper LChunk Weak.
  remember (n-m) as p.
  replace n with (m + p) in * by lia.
  assert(pNN: 0 <= p) by lia.
  revert Weak.

  apply natlike_rec2 with (z := p); auto with zarith.
  {
    intros.
    rewrite Zplus_0_r in *.
    unfold P_Increasing_1_.
    intros; auto with zarith. (* empty domain *)
  }
  {
    intros z zNN IHz.
    replace (Z.succ z) with (1 + z) in * by auto with zarith.
    intros Weak i j.
    intros.

    assert(X: j < m + z \/ j = m + z) by lia.
    destruct X as [lt|eq].
    {
      apply IHz; auto with zarith.
      unfold P_WeaklyIncreasing_1_.
      intros k. intros.
      apply Weak; auto with zarith.
    }
    {
      rewrite <- eq in *.
      assert(XX: i < j - 1 \/ i = j - 1) by lia.
      destruct XX as [lt1|eq1].
      {
        assert(Y: L .[ Compound.shift_sint32 a (j-1)] <= L .[ Compound.shift_sint32 a j]).
        {
          replace j with (1 + (j-1)) by auto with zarith.
          replace ((1 + (j - 1) - 1)) with (j-1) by auto with zarith.
          unfold P_WeaklyIncreasing_1_ in Weak.
          apply Weak; auto with zarith.
        }
        assert(Z: L.[ Compound.shift_sint32 a i] <= L .[ Compound.shift_sint32 a (j-1)]).
        {
          apply IHz; auto with zarith.
          unfold P_WeaklyIncreasing_1_.
          intros k. intros.
          apply Weak; auto with zarith.
        }
        auto with zarith.
      }
      {
        replace j with (1 + (j - 1)) by auto with zarith.
        rewrite eq1.
        apply Weak; auto with zarith.
      }
    }
  }
Qed.

Goal typed_external_lemma_WeaklyIncreasing_Shift.
Hint WeaklyIncreasing_Shift,property.
Proof.
Require Import Psatz.
intros n m L a LChunk.
unfold P_WeaklyIncreasing_1_.
unfold shift_sint32.
split.
+ intros H i LB UB.
  remember (i - n)%Z as k.
  assert (LBZ: (0 <= k)%Z) by lia.
  assert (UBZ: (2 + k <= m)%Z) by lia.
  replace i with (n + k)%Z by lia.
  rewrite <- shift_associative.
  replace (1 + (n + k))%Z with (n + (1 + k))%Z by lia.
  rewrite <- shift_associative.
  now apply H.
+ intros H i LB UB.
  remember (i + n)%Z as k.
  rewrite shift_associative.
  rewrite shift_associative.
  replace (n + (1 + i))%Z with (1 + (n + i))%Z by lia.
  apply H with (i := (n + i)%Z); auto with zarith.
Qed.

Goal typed_external_lower_bound_ensures_result.
Hint default,lower_bound,property,result.
Proof.
  auto with zarith.
Qed.

Goal typed_external_max_element2_loop_invariant_bound_preserved.
Hint bound,max_element2,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_max_element_loop_invariant_bound_preserved.
Hint bound,max_element,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_max_element_not_empty_ensures_first.
Hint first,max_element,not_empty,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_max_element_not_empty_ensures_upper.
Hint max_element,not_empty,property,upper.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_increasing_10.
Hint increasing,merge,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_increasing_12.
Hint increasing,merge,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_increasing_16.
Hint increasing,merge,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_increasing_2_part2.
Hint increasing,merge,part-1,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_increasing_2_part4.
Hint increasing,merge,part-3,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_increasing_4_part3.
Hint increasing,merge,part-2,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_increasing_6_part3.
Hint increasing,merge,part-2,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_index_3.
Hint index,merge,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow.
Hint merge,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_2.
Hint merge,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_2_part1.
Hint merge,part-0,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_2_part2.
Hint merge,part-1,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_3.
Hint merge,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_3_part1.
Hint merge,part-0,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_4.
Hint merge,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_4_part1.
Hint merge,part-0,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_6.
Hint merge,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_6_part1.
Hint merge,part-0,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_6_part3.
Hint merge,part-2,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_8.
Hint merge,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_8_part2.
Hint merge,part-1,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_8_part4.
Hint merge,part-3,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_rte_unsigned_overflow_part1.
Hint merge,part-0,property,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_assert_upper_4.
Hint merge,property,upper.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_2_preserved.
Hint increasing,merge,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_2_preserved_part3.
Hint increasing,merge,part-2,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_3_preserved.
Hint increasing,merge,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_4_preserved_part1.
Hint increasing,merge,part-0,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_4_preserved_part2.
Hint increasing,merge,part-1,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_4_preserved_part3.
Hint increasing,merge,part-2,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_4_preserved_part4.
Hint increasing,merge,part-3,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_5_preserved_part3.
Hint increasing,merge,part-2,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_5_preserved_part4.
Hint increasing,merge,part-3,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_6_preserved_part3.
Hint increasing,merge,part-2,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_preserved.
Hint increasing,merge,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_preserved_part1.
Hint increasing,merge,part-0,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_increasing_preserved_part5.
Hint increasing,merge,part-4,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_index_2_preserved.
Hint index,merge,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_index_4_preserved.
Hint index,merge,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_merge_loop_invariant_index_preserved.
Hint index,merge,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_min_element_loop_invariant_bound_preserved.
Hint bound,min_element,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_minmax_element_loop_invariant_bound_preserved.
Hint bound,minmax_element,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_mismatch_loop_invariant_bound_preserved.
Hint bound,mismatch,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_partial_sort_assert_lower_4.
Hint lower,partial_sort,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_partial_sort_loop_invariant_bound_preserved.
Hint bound,partial_sort,preserved.
Proof.
  auto with zarith.
Qed.

Goal typed_external_partial_sum_assert_limits_2.
Hint limits,partial_sum,property.
Proof.
  intros.
Qed.

Goal typed_external_partial_sum_assert_limits_3.
Hint limits,partial_sum,property.
Proof.
(* --------------------------------------
  
From 'typed_external_partial_sum_assert_limits_2': 
(* auto with zarith. *)
*)
Qed.

Goal typed_external_partial_sum_loop_invariant_limits_preserved.
Hint limits,partial_sum,preserved.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_partial_sum_loop_invariant_partialsum_preserved.
Hint partial_sum,partialsum,preserved.
Proof.
(* --------------------------------------
  
From 'typed_external_partial_sum_loop_invariant_limits_preserved': 
(* auto with zarith. *)
*)
Qed.

Goal typed_external_pop_heap_assert_back.
Hint back,pop_heap,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_assert_child.
Hint child,pop_heap,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_assert_heap_6.
Hint heap,pop_heap,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_pop_heap_assert_less_2.
Hint less,pop_heap,property.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_assert_update.
Hint pop_heap,property,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_assert_update_2.
Hint pop_heap,property,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_assert_update_3.
Hint pop_heap,property,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_call_heap_child_2_requires_bounds.
Hint pop_heap,precond-heap_child.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_call_heap_child_max_2_requires_bound_2.
Hint pop_heap,precond-heap_child_max.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_loop_invariant_heap_2_established.
Hint established,heap,pop_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_loop_invariant_update_established.
Hint established,pop_heap,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_loop_invariant_update_preserved.
Hint pop_heap,preserved,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_pop_heap_loop_variant_positive.
Hint pop_heap,positive.
Proof.
  auto with zarith.
Qed.

Goal typed_external_push_heap_assert_add.
Hint add,property,push_heap.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_push_heap_assert_adjust.
Hint adjust,property,push_heap.
Proof.
(* --------------------------------------
  
From 'typed_external_push_heap_assert_retain_3': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_retain_2': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_reorder_3': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_retain_3': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_retain_2': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
Qed.

Goal typed_external_push_heap_assert_bound.
Hint bound,property,push_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_push_heap_assert_minus.
Hint minus,property,push_heap.
Proof.
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
Qed.

Goal typed_external_push_heap_assert_reorder_3.
Hint property,push_heap,reorder.
Proof.
(* --------------------------------------
  
From 'typed_external_push_heap_assert_retain_3': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_retain_2': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
Qed.

Goal typed_external_push_heap_assert_retain_2.
Hint property,push_heap,retain.
Proof.
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
Qed.

Goal typed_external_push_heap_assert_retain_3.
Hint property,push_heap,retain.
Proof.
(* --------------------------------------
  
From 'typed_external_push_heap_assert_retain_2': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_minus': 
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
*)
(* --------------------------------------
  
From 'typed_external_push_heap_assert_add': 
(* auto with zarith. *)
*)
Qed.

Goal typed_external_push_heap_assert_update_4.
Hint property,push_heap,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_random_number_assert_rte_unsigned_downcast.
Hint property,random_number,rte,unsigned_downcast.
Proof.
  auto with zarith.
Qed.

Goal typed_external_remove_copy3_assert_mapping.
Hint mapping,property,remove_copy3.
Proof.
(* --------------------------------------
  
From 'typed_external_remove_copy3_assert_remove_2': 
(* auto with zarith. *)
*)
(* --------------------------------------
  
From 'typed_external_remove_copy3_assert_remove': 
(* --------------------------------------
  
From 'typed_external_remove_copy3_assert_remove_2': 
(* auto with zarith. *)
*)
*)
Qed.

Goal typed_external_remove_copy3_assert_remove.
Hint property,remove,remove_copy3.
Proof.
(* --------------------------------------
  
From 'typed_external_remove_copy3_assert_remove_2': 
(* auto with zarith. *)
*)
Qed.

Goal typed_external_remove_copy3_assert_remove_2.
Hint property,remove,remove_copy3.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_external_remove_loop_invariant_unchanged_2_established.
Hint established,remove,unchanged.
Proof.
  auto with zarith.
Qed.

Goal typed_external_replace_copy_loop_invariant_bounds_preserved.
Hint bounds,preserved,replace_copy.
Proof.
  auto with zarith.
Qed.

Goal typed_external_replace_loop_invariant_bounds_preserved.
Hint bounds,preserved,replace.
Proof.
  auto with zarith.
Qed.

Goal typed_external_reverse_assert_rte_unsigned_overflow.
Hint property,reverse,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_reverse_copy_assert_rte_unsigned_overflow.
Hint property,reverse_copy,rte,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_reverse_copy_loop_invariant_bound_preserved.
Hint bound,preserved,reverse_copy.
Proof.
  auto with zarith.
Qed.

Goal typed_external_reverse_loop_invariant_bound_preserved.
Hint bound,preserved,reverse.
Proof.
  auto with zarith.
Qed.

Goal typed_external_search_loop_invariant_bound_established.
Hint bound,established,search.
Proof.
  auto with zarith.
Qed.

Goal typed_external_search_n_assert_bound_2.
Hint bound,property,search_n.
Proof.
  auto with zarith.
Qed.

Goal typed_external_search_n_ensures_result_part1.
Hint default,part-0,property,result,search_n.
Proof.
  auto with zarith.
Qed.

Goal typed_external_search_n_ensures_result_part4.
Hint default,part-3,property,result,search_n.
Proof.
  auto with zarith.
Qed.

Goal typed_external_search_n_loop_invariant_bound_preserved_part4.
Hint bound,part-3,preserved,search_n.
Proof.
  auto with zarith.
Qed.

Goal typed_external_search_n_loop_variant_positive_part1.
Hint part-0,positive,search_n.
Proof.
  auto with zarith.
Qed.

Goal typed_external_selection_sort_assert_rte_unsigned_overflow_3.
Hint property,rte,selection_sort,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_assert_less_2.
Hint less,property,sift_down_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_assert_rte_unsigned_overflow.
Hint property,rte,sift_down_heap,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_assert_update.
Hint property,sift_down_heap,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_assert_update_2.
Hint property,sift_down_heap,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_loop_invariant_child_established.
Hint child,established,sift_down_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_loop_invariant_max_established.
Hint established,max,sift_down_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_loop_invariant_unchanged_2_established.
Hint established,sift_down_heap,unchanged.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_loop_invariant_update_established.
Hint established,sift_down_heap,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sift_down_heap_loop_invariant_update_preserved.
Hint preserved,sift_down_heap,update.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sort_heap_assert_rte_unsigned_overflow.
Hint property,rte,sort_heap,unsigned_overflow.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sort_heap_call_pop_heap_requires_bounds.
Hint precond-pop_heap,sort_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sort_heap_ensures_reorder.
Hint default,property,reorder,sort_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sort_heap_ensures_reorder_3.
Hint default,property,reorder,sort_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_sort_heap_loop_invariant_bound_preserved.
Hint bound,preserved,sort_heap.
Proof.
  auto with zarith.
Qed.

Goal typed_external_stack_size_ensures_size.
Hint default,property,size,stack_size.
Proof.
  auto with zarith.
Qed.

Goal typed_external_stack_top_ensures_top.
Hint default,property,stack_top,top.
Proof.
  auto with zarith.
Qed.

Goal typed_external_swap_ranges_loop_invariant_bound_preserved.
Hint bound,preserved,swap_ranges.
Proof.
  auto with zarith.
Qed.


